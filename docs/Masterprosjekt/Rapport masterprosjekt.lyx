#LyX 1.6.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\usepackage{subfigure}
\usepackage{gensymb}
\usepackage[noauto]{chappg}
\usepackage{fancyhdr}
\usepackage{lmodern}

\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\bfseries}
{\end{list}}

\newenvironment{mytinylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\tiny\bfseries}
{\end{list}}
\end_preamble
\options twoside
\use_default_options true
\language english
\inputencoding auto
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing other 1.2
\use_hyperref true
\pdf_title "Simulation of Small-Scale Autonomous Helicopters"
\pdf_author "Andreas Larsen"
\pdf_keywords "UAV, simulation, autonomous, helicopter, robot"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip bigskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagestyle{fancy}
\end_layout

\begin_layout Plain Layout


\backslash
fancyhead[R]{}
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset VSpace 2.5cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
Abstract
\end_layout

\begin_layout Standard
This thesis describes autopilot simulation software designed to let a helicopter
 fly autonomously in a virtual game world.
 We continue the work from our previous study 
\begin_inset Quotes eld
\end_inset

Methods of Real-Time Flight Simulation
\begin_inset Quotes erd
\end_inset

 and describe a proof of concept implementation.
 We explore the challenges of state estimation, control logic, virtual sensors,
 physics and visualization and describe the methods we used.
 We identify some key concerns when designing software for autopilot simulation
 and propose a software architecture with tactics that promote modifiability,
 performance and portability to facilitate future extensions of the work.
 
\end_layout

\begin_layout Standard
We propose a method of autopilot control to safely navigate waypoints and
 our experiments verified that the autopilot could successfully navigate
 a variation of scenarios with different levels of state knowledge.
 We also propose a method for autopilot assisted control that enables a
 person with no flying experience to safely maneuver a helicopter by joystick.
 
\end_layout

\begin_layout Standard
The results verified the functionality of the GPS/INS Kalman filter implementati
on that significantly improved the position estimates.
 However, our position estimates were 40% more accurate than the results
 in related work when real sensors were used, which indicate a need for
 more accurate modelling of virtual sensors and physics to simulate autonomous
 flights with sufficiently realistic results.
\end_layout

\begin_layout Standard
The methods and findings in this thesis are viable for reuse in a number
 of autonomous control applications, including real navigation of unmanned
 aerial vehicles and dynamic AI control of aircrafts in computer games.
\end_layout

\begin_layout Chapter*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Acknowledgements}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We would like to thank professor Torbjørn Hallgren for allowing us to take
 on this inter-disciplinary thesis and for his time spent on guidance and
 feedback during both the thesis and the pre-study.
 We are grateful for access to the high-end equipment and computers that
 were made available through his dedication to the visualization department
 at NTNU.
 
\end_layout

\begin_layout Standard
We want to thank co-supervisor Jo Skjermo for his technical insight and
 assistance in using the laboratory equipment and for feedback on the written
 reports.
 Finally, we would like to thank co-supervisor Helge Langseth for assistance
 on state estimation theory and feedback on the written reports.
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Table of Contents}
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{List of Figures}
\end_layout

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{List of Algorithms}
\end_layout

\end_inset


\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Nomenclature}
\end_layout

\end_inset


\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
This thesis presents our implementation of a simulator software for autonomous
 flight and the findings of experimenting with different sensor configurations.
 The implementation is largely based on our previous study 
\begin_inset Quotes eld
\end_inset

Methods of Real-Time Flight Simulation
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "a2ds_project"

\end_inset

 and as a proof-of-concept we achieved fully autonomous flight of a helicopter
 in a virtual game world.
 
\end_layout

\begin_layout Standard
The pre-study holds the details to the concepts of aerodynamics and methods
 of visualization so we will only mention those briefly where appropriate.
 Instead we focus here on the implementation of the methods, the software
 architecture designed to tie the components together and the findings of
 our experiments.
 After reading this thesis the reader should be well-equipped to understand
 the key concepts of regulatory systems and how we applied inter-disciplinary
 methods to implement a working autopilot.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
The field of robotics has gained significant interest over the last two
 decades and its applications are ever increasing.
 This project was inspired from the idea that swarms of cheap off-the-shelf
 model aircrafts could solve tasks safely and efficiently.
 The costs of issuing a search and rescue helicopter are tremendous and
 it takes a lot of time to cover a large area.
 With swarms one could ideally launch hundreds or even thousands of drones
 capable of navigating and identifying objects by themselves and sending
 live pictures to a ground station.
 This way a large area would be covered more quickly and potentially a lot
 cheaper.
 For hazardous tasks, such as in irradiated areas or in extreme weather
 conditions, the drones could be sent instead to avoid putting humans at
 risk.
\end_layout

\begin_layout Standard
In order to develop autopilots safely, efficiently and with minimal risk
 of failure it is necessary to have a realistic and flexible simulator software
 to test the autopilots on.
 Implementing such a simulator is the motivation for this thesis.
\end_layout

\begin_layout Section
Context
\end_layout

\begin_layout Standard
There is a lot of prior work in the field of robotics and autopilots, but
 much of the available work is academic and difficult to apply in practice
 without in-depth knowledge.
 This thesis does an important job in identifying and combining academic
 methods from multiple disciplines of science such as mathematics, physics,
 cybernetics and computers.
 Our academic background was largely from computer science and game technology
 and this was to our advantage when describing our implementation for entry
 level readers, since we started out at an entry level in the field of robotics
 ourselves.
 The proof-of-concept implementation gives the thesis a practical perspective
 of things and should prove useful for anyone interested in simulating flight
 behavior and autonomous vehicles.
\end_layout

\begin_layout Section
Intended Audience
\end_layout

\begin_layout Standard
This thesis is relevant for any reader interested in an entry level introduction
 to state estimation, autopilot control logic and flight simulation.
 We will cover the key methods used in our implementation and it is assumed
 that the reader has an academic background in computer science and a good
 understanding of graduate level calculus and physics.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
Chapters 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Previous-Work"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Theoretical-Background"

\end_inset

 provide a summary of the key findings in the pre-study, similarities and
 differences of our solution compared to related work and provides a theoretical
 background required to understand the methods used and the choices made
 in the implementation.
\end_layout

\begin_layout Standard
Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Implementation"

\end_inset

 describes key implementation details and issues of the autopilot simulator
 and chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Results"

\end_inset

 presents the results of the autopilot performance for different navigation
 scenarios with different sensor configurations.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Discussion"

\end_inset

 discusses shortcomings, issues and how the proof-of-concept implementation
 matched our expectations and goals.
 We summarize the key findings in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Conclusion"

\end_inset

 and present ideas for future work and enhancements in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Future-Work"

\end_inset

.
\end_layout

\begin_layout Standard
Appendices 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-UserManual"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-PrecisionIssues"

\end_inset

 hold documentation of user manuals, configuration files, sensor datasheets
 and precision issue details.
\end_layout

\begin_layout Chapter
Previous Work
\begin_inset CommandInset label
LatexCommand label
name "cha:Previous-Work"

\end_inset


\end_layout

\begin_layout Standard
Prior to this thesis we did a pre-study on methods of real-time flight simulatio
n.
 The focus here was to identify methods and theory for simulating and visualizin
g aircraft flight.
 Here we will summarize the key findings relevant for our implementation.
\end_layout

\begin_layout Paragraph
Introduction to Aerodynamics
\end_layout

\begin_layout Standard
The pre-study describes key aerodynamic phenomena behind heavier-than-air
 flight and for our implementation we focus on the forces of 
\emph on
lift
\emph default
 and 
\emph on
drag
\emph default
.
 For helicopters, the main source of lift are the rotor blades of the main
 rotor.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Relative-airflow-passing"

\end_inset

 illustrates a simplified view of how lift is generated by placing a wing
 at an angle in an airflow.
 Although the process is more complicated than this, one can think of air
 as being accelerated downwards by the wing and the reaction force will
 cause the wing to accelerate upwards.
 The rotor blades work much in the same way as wings on airplanes and simply
 put; if the rotor speed is increased or the rotor blades are angled steeper,
 then the lifting force will increase.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Physics/lift.jpg
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Relative airflow passing over an airfoil and generating lift.
\begin_inset CommandInset label
LatexCommand label
name "fig:Relative-airflow-passing"

\end_inset

 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "watkinson04"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Drag is typically an undesirable property when flying as it resists the
 motion of bodies through air.
 There a number of different types of drag, but the most significant types
 of drag for small model helicopters is
\emph on
 parasite
\emph default
 and 
\emph on
induced 
\emph default
drag.
 Parasite drag covers all forms of drag that are not related to the generation
 of lift.
 The most significant types of parasite drag are 
\emph on
form drag
\emph default
 and 
\emph on
skin friction
\emph default
.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Form-drag-and"

\end_inset

 shows how blunt body shapes have significant form drag, while streamlined
 shapes have more skin friction.
 Intuitively, form friction has a large impact on the magnitude of parasite
 drag so streamlined wings are preferred.
\end_layout

\begin_layout Standard
Induced drag is simply a result of the lift vector being directed up and
 slightly backwards due to the angle of attack of the wing.
 The force component that is opposite to the wing motion will then be perceived
 as drag.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Physics/form_vs_skin_bw.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Form drag and skin friction for different types of shapes.
\begin_inset CommandInset label
LatexCommand label
name "fig:Form-drag-and"

\end_inset

 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "drag_wiki"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Flight Dynamics Model
\end_layout

\begin_layout Standard
The pre-study describes methods to analyze the aerodynamical forces for
 use in flight simulation.
 From these methods we proposed four types of flight dynamics models (FDM
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "FDM"
description "Flight Dynamics Model, a method for describing flight behavior."

\end_inset

s) to define the flight behavior, as shown in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:flight-dynamics-models"

\end_inset

.
 The FDMs are listed as #1 being the most complex and comprehensive method
 and #4 being the simplest.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="1cm">
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="9cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Method(s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CFD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simulate the interacting forces of air and the aircraft structure by some
 governing equation for air
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CFD + Parametric
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Determine the lift and drag coefficients by simulating the air in a virtual
 wind tunnel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parametric
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Use published wind tunnel test data for specific aircraft models
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parametric
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pick lift and drag coefficients that give reasonable max velocities and
 control responses
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Different combinations of computational fluid dynamics and parametric equations
 to model the flight dynamics.
\begin_inset CommandInset label
LatexCommand label
name "tab:flight-dynamics-models"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two methods outlined in the table; Computational Fluid Dynamics
 and parametric equations.
 CFD attempts to simulate the effects of air around the aircraft by solving
 equations of fluid dynamics.
 Any substance that flows is classified as a fluid and this includes gases,
 such as air.
 The problem with CDF is that the equations are closely coupled and hard
 to solve without major simplifications.
 Solutions today are computationally expensive and require high resolution
 grids to accurately model the turbulent, high-velocity airflows around
 an aircraft.
\end_layout

\begin_layout Standard
Parametric equations are much simpler and if implemented properly can still
 present a good approximation.
 FDM #3 is often used in PC simulator games today and use published wind
 tunnel test data to realistically model the effects of varying airflows
 around specific aircraft models.
 FDM #2 is a combination and also used in modern simulator games.
 For real-time performance the method solves parametric equations based
 on CFD or structural analysis of the aircraft body.
 This analysis can be very time consuming, but allows the model to accurately
 represent the flight behavior of an arbitrary aircraft design.
\end_layout

\begin_layout Standard
In the pre-study we suggested to start out with FDM #4 and later extend
 to more realistic models if time allowed us to.
 As we describe in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Physics"

\end_inset

, we ended up using FDM #4 and choosing lift and drag coefficients on an
 empirical basis.
 Although the method is simple it proved to be a good approximation to small-sca
le helicopters with properly chosen coefficients.
\end_layout

\begin_layout Chapter
Related Work
\begin_inset CommandInset label
LatexCommand label
name "cha:Related-Work"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
stanford heli, yamaha heli
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a lot of prior work in the field of autopiloting and here we describe
 a few projects that provided us with the necessary background to approach
 the task.
 We will briefly cover parts of the related work that were useful to us,
 how we made use of this information and discuss if our approach differed
 in any way.
\end_layout

\begin_layout Section
GPS/IMU Data Fusion for USV
\end_layout

\begin_layout Standard
One article 
\begin_inset CommandInset citation
LatexCommand cite
key "gpsimu_fusion06"

\end_inset

 describes a GPS/INS Kalman filter that takes context and validity domains
 into consideration to further increase the estimate reliability.
 Large parts of this article was relevant to us to get an understanding
 of how to apply a Kalman filter for GPS/INS filtering.
 In particular, we found that their sensor specifications matched up with
 the ones we were simulating so we could compare the performance of our
 state estimation to theirs.
 Their vehicle was not aerial, but as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Sensors"

\end_inset

 we intentionally limited our vertical estimate error during flight to focus
 on the horizontal position estimate error.
 The test results showed that our simulation with similarly specified sensors
 produced 40% less position estimate errors and we discuss these findings
 later in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Discussion"

\end_inset

.
\end_layout

\begin_layout Section
GPS/INS/Vision Data Fusion for UAV
\end_layout

\begin_layout Standard
One paper 
\begin_inset CommandInset citation
LatexCommand cite
key "kf_gpsinsvision"

\end_inset

 describes how a vision system mounted on a helicopter could increase the
 state estimation accuracy of a GPS/INS system.
 We found this paper useful as an introduction to GPS/INS Kalman filtering
 and their vision system was a novel addition we had not seen before.
 They used a laser range finder to measure the vertical distance to the
 ground and a video camera system to estimate horizontal motion.
 To accurately measure motion and height above the ground are some of the
 biggest weaknesses of GPS and INS systems so the vision system should prove
 useful for low altitude navigation scenarios as well as landing and take
 off.
 
\end_layout

\begin_layout Standard
In our implementation we implemented a sonic range finder that served the
 same purpose as the laser equivalent.
 This enabled our autopilot to perform low altitude navigation and to follow
 the curvature of the terrain without crashing.
\end_layout

\begin_layout Section
Do It Yourself UAV
\end_layout

\begin_layout Standard
Do It Yourself UAV 
\begin_inset CommandInset citation
LatexCommand cite
key "autopilot09"

\end_inset

 (DIY
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "DIY"
description "Do It Yourself UAV, an open source autopilot project."

\end_inset

) is an open source project that started in August 2001 and gained a lot
 of interest in the UAV
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "UAV"
description "Unmanned Aerial Vehicle"

\end_inset

 community even though the project stopped its activities two years later.
 The goal was to establish a free software base and design a cheap hardware
 setup that any hobbyist could build and extend themselves for autonomous
 helicopter flight.
 
\end_layout

\begin_layout Standard
The project spans a working autopilot software, a list of sensors and components
 to use and complete electronic board designs to assemble the autopilot.
 The website has a few videos that showcase semi-autonomous outdoor flight,
 where cyclic and tail is fully controlled by the autopilot to hold a position,
 while the thrust is controlled by a human operator.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/helicopter_bench.jpg
	lyxscale 50
	width 12cm

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
The remote controlled helicopter with sensors mounted and the operator ground
 station.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "autopilot09"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
DIY is interesting because a tremendous amount of solid work was put down
 by a large number of people for the benefit of the community.
 It was one of the first hobbyist projects to succeed with a home user budget
 and the do-it-yourself recipe made it a pioneer in the hobbyist community.
\end_layout

\begin_layout Standard
The work of DIY is very related to this project and both try to achieve
 fully autonomous flight using sensors and autopilot software.
 However, we focus on simulating behavior and benchmarking autopilot performance
 in a virtual world whereas DIY started experimenting on real helicopters
 early on in the project.
 
\end_layout

\begin_layout Standard
The advantage of our approach is that it focuses on simulating the autopilot
 and its sensors to test out the autopilot performance.
 This allows for safer and cheaper experimenting and should prove more reliable
 if deployed on a real model helicopter later.
 
\end_layout

\begin_layout Section
MSc Thesis on UAV INS/GPS Navigation Loop
\end_layout

\begin_layout Standard
Sven Rönnbäck wrote a master's thesis 
\begin_inset CommandInset citation
LatexCommand cite
key "ronnback:msc"

\end_inset

 in 2000 on combining an inertial navigation system (INS) with a GPS system
 to estimate the flight path of an airplane drone.
 The thesis was written as Rönnbäck's contribution to the work of a large
 team of researchers on autonomous flight, depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-research-team"

\end_inset

, and has many similarities to our project.
 However, his work is solely focused on offline state estimation so there
 is no autopilot control logic or descriptions on using the state estimates
 to control a vehicle.
 Instead his work was based on logs of sensor data from manual test flights
 with their UAV to evaluate the performance of the state estimator by comparing
 the estimated and the true flight trajectories.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Related Work/Ronnback.PNG
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The research team and the UAV of Rönnbäck's work.
\begin_inset CommandInset label
LatexCommand label
name "fig:The-research-team"

\end_inset

 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "ronnback:msc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our state estimation also relies on the INS/GPS Kalman filter method so
 his work was of great use for us to learn the ins and outs of aircraft
 state estimation.
 In section  
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Impl"

\end_inset

 we go into detail on how we implemented the state estimator and how it
 serves as an information source to our autopilot component.
\end_layout

\begin_layout Section
MSc Thesis on USV Controller Design
\end_layout

\begin_layout Standard
Geir Beinset and Jarle Saga Blomhoff wrote a master's thesis 
\begin_inset CommandInset citation
LatexCommand cite
key "beinset:msc"

\end_inset

 in 2007 on the design of a heading autopilot and waypoint navigation system
 for a propeller-driven boat
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "USV"
description "Unmanned Surface Vehicle"

\end_inset

.
 
\end_layout

\begin_layout Standard
The problem they approached was to determine an accurate representation
 of the boat in a simulation software by doing actuator-response tests on
 the full scale rig.
 This way they could design the autopilot in simulation software before
 implementing and testing on the USV.
\end_layout

\begin_layout Standard
The relevant part of this thesis is how they make use of the control theory
 discussed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Control-Theory"

\end_inset

 and how they use system identification to determine the boat's behavior
 for accurate simulation.
 In particular, the system identification method could prove valuable for
 our scenario to minimize the error in flight simulation.
 Interesting properties of a helicopter would be the responsiveness of thrust,
 cyclic and tail control at different relative air flows.
\end_layout

\begin_layout Chapter
Theoretical Background
\begin_inset CommandInset label
LatexCommand label
name "cha:Theoretical-Background"

\end_inset


\end_layout

\begin_layout Standard
The previous chapters summarized the findings of our pre-study and related
 work.
 In this chapter we provide a thorough background to relevant theory of
 reference frames and orientational representations, regulatory systems
 and state estimation that are essential for the methods used in our implementat
ion.
 
\end_layout

\begin_layout Section
Reference Frames
\end_layout

\begin_layout Standard
In order to describe position, orientation and scale we need a reference
 frame and in autopilots we typically operate with two frames.
 One relative to the vehicle and one for navigation.
 This section will provide the background to understand the reference frames
 used in the implementation.
 
\end_layout

\begin_layout Subsection
Body Frame
\end_layout

\begin_layout Standard
The body frame is the coordinate system relative to the vehicle.
 The frame is a Cartesian coordinate system and we chose to use a forward-right-
up (FRU
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "FRU"
description "Forward-Right-Up naming convention for the axes in body frame."

\end_inset

) naming convention corresponding to the -Z, +X and +Y axes in the XNA Game
 Studio framework that we implemented our virtual world in.
 
\end_layout

\begin_layout Standard
Body frame is used for the inertial sensors mounted on the vehicle since
 their values are relative to the mounting.
 For instance the accelerometer sensor measures acceleration in the body
 frame, assuming its mounting is aligned with the vehicle.
 In order to calculate changes in world position and velocity we must first
 transform the acceleration vector from body frame to navigation frame.
\end_layout

\begin_layout Subsection
Navigation Frame
\end_layout

\begin_layout Standard
In order to describe position, velocity and acceleration in the world we
 need a navigation frame.
 This frame can be said to represent a map and serves as a mapping between
 a position in the navigation frame and a position in the world.
\end_layout

\begin_layout Subsubsection
Earth ENU/NED Frames
\end_layout

\begin_layout Standard
There are a number of common navigation frames, but one covered in 
\begin_inset CommandInset citation
LatexCommand cite
key "ronnback:msc"

\end_inset

 is the Earth North-East-Down (NED
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "NED"
description "Earth north-east-down reference frame."

\end_inset

) frame as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Earth-NED-frame"

\end_inset

.
 Here a position on the Earth surface is chosen as origin and then the position
 is described as a local north-east-down vector relative to the origin.
 When flying most objects of interest are below you so that is why the down
 vector is chosen in many aviation applications.
 Alternatively one can use the local east-north-up (ENU
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ENU"
description "Earth east-north-up reference frame."

\end_inset

) frame, which is preferred for ground tracking applications such as GPS.
 These frames are typically used for short range navigation where the curvature
 of the Earth is considered negligible and this fit our navigation scenarios
 well.
 In our implementation we used NED.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Reference Frames/NED_frame.png
	lyxscale 50
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Earth NED navigation frame.
\begin_inset CommandInset label
LatexCommand label
name "fig:Earth-NED-frame"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Geodetic Frames
\end_layout

\begin_layout Standard
Although we used the NED frame in our implementation there are a number
 of other frames that one may have to consider for aircraft autopilots.
 For instance, flights over long distances require us to consider the elliptical
 shape of the Earth when representing the position, such as the World Geodetic
 System 1984 (WGS-84
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "WGS-84"
description "World Geodetic System 1984"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "farrel_reference_frames"

\end_inset

.
 WGS-84 describes a position by longitude, latitude and height and is widely
 used in maps and GPS trackers.
 
\end_layout

\begin_layout Section
Representing Rotations
\end_layout

\begin_layout Standard
We used rotations for a number of objects in the world such as cameras,
 the helicopter and its main rotor.
 According to 
\begin_inset CommandInset citation
LatexCommand cite
key "rotation_reps"

\end_inset

 there are three widely used methods for representing rotations; namely
 matrices, Euler angles and quaternions.
 Each have its pros and cons and we will identify how these methods fit
 our implementation.
 
\end_layout

\begin_layout Subsection
Clarifying Terms
\end_layout

\begin_layout Standard
The terms 
\emph on
orientation
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Orientation"
description "The direction an object is facing relative to some identity state."

\end_inset


\emph default
 and 
\emph on
rotation
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Rotation"
description "A description on how to transition from one orientation to another."

\end_inset


\emph default
 are often used interchangeably, but as noted in 
\begin_inset CommandInset citation
LatexCommand cite
key "rotation_reps"

\end_inset

 there are subtle differences.
 An orientation can be considered as the direction an object is facing relative
 to some identity state, while a rotation (or 
\emph on
angular displacement
\emph default
) describes how to transition from one orientation to another.
 In other words, applying a rotation to an orientation produces a new orientatio
n.
 We will stick with this convention here.
\end_layout

\begin_layout Subsection
Rotation Matrix
\begin_inset CommandInset label
LatexCommand label
name "sub:Rotation-Matrix"

\end_inset


\end_layout

\begin_layout Standard
A rotation matrix represents a rotation, but more specifically it represents
 a transformation of vectors from one coordinate space to the other.
 In 3D the 3x3 matrix simply lists the three basis vectors 
\begin_inset Formula $\hat{\mathbf{u}}$
\end_inset

, 
\begin_inset Formula $\hat{\mathbf{v}}$
\end_inset

 and 
\begin_inset Formula $\hat{\mathbf{w}}$
\end_inset

 of one coordinate space expressed in the other coordinate space (XYZ).
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathbf{A}=\left[\begin{array}{ccc}
\hat{\mathbf{u}}_{x} & \hat{\mathbf{u}}_{y} & \hat{\mathbf{u}}_{z}\\
\hat{\mathbf{v}}_{x} & \hat{\mathbf{v}}_{y} & \hat{\mathbf{v}}_{z}\\
\hat{\mathbf{w}}_{x} & \hat{\mathbf{w}}_{y} & \hat{\mathbf{w}}_{z}\end{array}\right]\begin{array}{c}
(new\, x-axis)\\
(new\, y-axis)\\
(new\, z-axis)\end{array}\]

\end_inset


\end_layout

\begin_layout Standard
Summary of the rotation matrix representation:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Pros
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Explicit basis vectors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Because the rotation matrix is defined explicitly by the three new basis
 vectors they are readily available.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Concatenation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiple rotations can be concatenated into a single rotation matrix, which
 greatly simplifies nested coordinate space relationships.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inverse rotation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The rotation from B to A is easily obtained by matrix inversion of the rotation
 from A to B.
 Since the basis vectors are orthogonal the inverse is simply the transpose
 of the matrix.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Graphics APIs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modern graphics APIs such as OpenGL and DirectX use rotation matrices.
 This means the representation can be used directly without any transformation.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cons
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
This representation is the largest of the three, using 9 numbers to represent
 an orientation.
 This is 3 times the cost of Euler angles.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Usability
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
This representation is not intuitive to work directly with for humans, as
 we cannot easily imagine a coordinate system by considering their three
 basis vectors.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Validity
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
It is possible for a rotation matrix to become invalid, causing its behavior
 to be unpredictable.
 If the basis vectors are not orthogonal or not of unit lengths the rotation
 matrix is not well-defined.
 This can happen due to floating-point round-off errors by 
\emph on
matrix creep
\emph default
 when concatenating many rotation matrices.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Euler Angles
\end_layout

\begin_layout Standard
In contrast to rotation matrices and quaternions the Euler angles explicitly
 represent an orientation.
 The idea is to represent an orientation as three sequential rotations around
 mutually perpendicular axes from an identity state.
 Rotations are not commutative so the order of rotations matters.
 Unfortunately there is no universal standard as there are different preferences
 to axes and orders.
 For instance, in physics the so-called 
\emph on
x-convention
\emph default
 uses rotations around X, Z and X while XNA uses the order Y, X and Z (yaw,
 pitch and roll).
 This means that in an implementation one needs to choose a convention and
 stick with it.
 Since we are using the XNA framework we will be using Y-X-Z Euler angles.
\end_layout

\begin_layout Standard

\emph on
Tait–Bryan angles
\emph default
 is a standard convention in aviation used to define the aircraft attitude
 by yaw, pitch and roll around the Z, Y and X axes.
 This is identical to our XNA convention except that the names of the axes
 are chosen differently.
\end_layout

\begin_layout Standard
Summary of the Euler angle representation:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Pros
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Usability
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Humans prefer to think in angles so working directly with Euler angles is
 intuitive.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Using only three numbers to represent an orientation, Euler angles is the
 smallest representation of the three.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Validity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
It is by definition not possible to get an 
\emph on
invalid
\emph default
 Euler angle representation.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cons
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aliasing
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Euler angles suffers from 
\emph on
aliasing
\emph default
; that one orientation is not uniquely represented by Euler angles.
 Multiples of 
\begin_inset Formula $360\degree$
\end_inset

 around any axis and other XYZ order conventions can be used to represent
 the same orientation.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gimbal lock
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Whenever the second rotation of a Euler angle representation is exactly
 
\begin_inset Formula $\pm90\degree$
\end_inset

 the first and third rotations are restricted to rotate around the same
 axis; known as a 
\emph on
gimbal lock
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Gimbal Lock"
description "At certain orientations in 3D two out of three gimbals are in the same plane losing one degree of freedom."

\end_inset

.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpolation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Euler angles are difficult to smoothly interpolate due to their representation.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Quaternions
\end_layout

\begin_layout Standard
Quaternions overcome the problems with gimbal lock and aliasing by adding
 a fourth number to the representation.
 The math behind quaternions is complicated and largely based on complex
 numbers, however intuitively we can think of a quaternion as an axis-angle
 pair.
 It describes the rotation as a rotation axis 
\begin_inset Formula $\mathbf{\overrightarrow{v}}(x,y,z)$
\end_inset

 and a rotation angle 
\begin_inset Formula $w$
\end_inset

 around that axis.
\end_layout

\begin_layout Standard
Summary of the quaternion representation:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Pros
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unique
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All orientations are represented uniquely and overcomes the above mentioned
 problems with aliasing and gimbal lock.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpolation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quaternions support smooth interpolations between orientations and 
\begin_inset CommandInset citation
LatexCommand cite
key "rotation_reps"

\end_inset

 describes mathematical methods for both linear and cubic interpolation.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The representation is only four numbers; 33% larger than Euler angles.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Concatenation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A sequence of rotations can be concatenated into a single quaternion.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Speed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
According to 
\begin_inset CommandInset citation
LatexCommand cite
key "rotation_reps"

\end_inset

 the performance of concatenation and rotation inversion is significantly
 faster than for rotational matrices and is faster than Euler angles to
 construct a rotation matrix from.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="middle" width="3cm">
<column alignment="left" valignment="top" width="12.5cm">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Cons
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Validity
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The accumulated floating-point errors can render the quaternion representation
 invalid.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Usability
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quaternions are the hardest representation for humans to work directly with.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Converting Rotation Matrix to Euler Angles
\end_layout

\begin_layout Standard
We define the rotations yaw, pitch and roll (Y-Z-X) in XNA as the Euler
 angles 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "$\\alpha$"
description "Yaw angle."

\end_inset

, 
\begin_inset Formula $\beta$
\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "$\\beta$"
description "Pitch angle."

\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "$\\psi$"
description "Roll angle."

\end_inset

.
 According to 
\begin_inset CommandInset citation
LatexCommand cite
key "rotation_reps"

\end_inset

 the rotation matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is defined as a product of three rotation matrices for the respective axes.
 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{R}=Rot(y,\alpha)\times Rot(x,\beta)\times Rot(z,\psi)\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We can express this matrix in terms of cosine and sine functions.
 In the matrix, 
\begin_inset Formula $c_{x}$
\end_inset

 represents 
\begin_inset Formula $\cos(x)$
\end_inset

 and 
\begin_inset Formula $s_{x}$
\end_inset

 represents 
\begin_inset Formula $\sin(x)$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{R}=\left[\begin{array}{ccc}
c_{\alpha}c_{\psi}-s_{\alpha}s_{\beta}s_{\psi} & -c_{\beta}s_{\psi} & c_{\psi}s_{\alpha}+c_{\alpha}s_{\beta}s_{\psi}\\
c_{\psi}s_{\alpha}s_{\beta}+c_{\alpha}s_{\psi} & c_{\beta}c_{\psi} & s_{\alpha}s_{\psi}-c_{\alpha}c_{\psi}s_{\beta}\\
-c_{\beta}s_{\alpha} & s_{\beta} & c_{\alpha}c_{\beta}\end{array}\right]\end{equation}

\end_inset


\end_layout

\begin_layout Standard
From the method proposed in 
\begin_inset CommandInset citation
LatexCommand cite
key "eulerangles_from_rotmat"

\end_inset

 we can identify the Euler angles from 
\begin_inset Formula $\mathbf{R}$
\end_inset

 by seeing the following relations.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\frac{\mathbf{R}_{31}}{\mathbf{R}_{33}}=-\frac{c_{\beta}s_{\alpha}}{c_{\alpha}c_{\beta}}=-\frac{s_{\alpha}}{c_{\alpha}}=-\tan(\alpha)\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\mathbf{R}_{32}=s_{\beta}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\frac{\mathbf{R}_{12}}{\mathbf{R}_{22}}=-\frac{c_{\beta}s_{\psi}}{c_{\beta}c_{\psi}}=-\frac{s_{\psi}}{c_{\psi}}=-\tan(\psi)\end{equation}

\end_inset


\end_layout

\begin_layout Standard
From this we can derive our yaw, pitch and roll angles.
 Since there is a choice of four quadrants for the inverse tangent function
 one can use the 
\begin_inset Formula $\arctan2(a,b)$
\end_inset

 function found in most math tools that handles this.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\alpha=-\arctan2(\mathbf{R}_{31},\mathbf{R}_{33})\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\beta=\arcsin(\mathbf{R}_{32})\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\psi=-\arctan2(\mathbf{R}_{12},\mathbf{R}_{22})\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It should be noted that as rotation matrices has an issue with singularities,
 the conversion to Euler angles also suffers from numeric instability.
 For instance when the pitch is exactly 
\begin_inset Formula $+90\degree$
\end_inset

 the yaw angle is no longer defined.
\end_layout

\begin_layout Subsection
Other conversions
\end_layout

\begin_layout Standard
In our implementation we also used other conversions such as from a quaternion
 to a rotation matrix, but these were not necessary to implement since the
 XNA framework had methods to do the conversions for us.
\end_layout

\begin_layout Subsection
Choice of Representations
\end_layout

\begin_layout Standard
We covered all three representations in detail since all of them were used
 in the implementation.
 Quaternions were used for camera and helicopter orientations in both the
 physics simulation and the state estimation components since they are fast,
 small, numerically stable and does not suffer from gimbal locks.
 The gimbal lock incident on the Apollo 11 moon mission is well known, because
 it caused critical navigation problems.
 Rotation matrices were used for rendering since the DirectX API requires
 us to and Euler angles were used to present the pitch, roll and yaw angles
 for debugging and autopilot configurations.
\end_layout

\begin_layout Section
Control Theory
\begin_inset CommandInset label
LatexCommand label
name "sec:Control-Theory"

\end_inset


\end_layout

\begin_layout Standard
The key problem of our implementation is how to design an autopilot that
 actually works.
 To attack this we need a fundamental understanding of control theory, what
 kinds of sensors exist and how they can be used to estimate the state of
 the helicopter.
 This section covers control theory and presents some simple examples on
 using PID-controllers to control a vehicle given knowledge about the vehicle
 position.
 The next section will introduce flight sensors and methods to construct
 this knowledge from noisy and incomplete measurements.
\end_layout

\begin_layout Subsection
Direct Digital Control
\begin_inset CommandInset label
LatexCommand label
name "sub:Direct-Digital-Control"

\end_inset


\end_layout

\begin_layout Standard
One of the simplest forms of control is 
\emph on
direct digital control
\emph default
 (DDC).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Direct-Digital-Control"

\end_inset

 illustrates how a simple digital device compares a sensor output with a
 desired value and regulates the device to minimize the error.
 One example is using a controller to regulate the room temperature.
 The logic in the controller can be very straight forward such as increasing
\emph on
 
\emph default
the heating effect if the room temperature decreases or it can use more
 sophisticated methods to better keep the room at a constant temperature.
 PID loop is one widely used method that allows the logic to be optimally
 tuned to a specific problem and is a building block for more complex controller
s.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/ddc.png
	height 6cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
DDC control loop.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "ddc09"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Direct-Digital-Control"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PID Loop Controller
\end_layout

\begin_layout Standard
A PID
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "PID"
description "A fundamental principle in control theory where proportional, integral and derivative measurements are used to minimize the difference of the current and the desired state."

\end_inset

 loop is a type of feedback loop that controls the behavior of the system
 through negative feedback.
 The system output is subtracted from the desired value to obtain an error
 value that is fed back into the controller loop and corrected for, as shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Negative-feedback-loop"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Figures/Control Theory/Negative Feedback Loop.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Negative feedback loop.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Negative-feedback-loop"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
PID loops make use of the 
\emph on
proportional, 
\emph default
the
\emph on
 integral 
\emph default
and the 
\emph on
derivative 
\emph default
of the error, hence the name PID, to produce a control value that reduces
 the error.
 A PID controller has the general form 
\begin_inset CommandInset citation
LatexCommand cite
key "copeland08"

\end_inset

 
\begin_inset Formula \begin{equation}
u(t)=\underset{P}{\underbrace{K_{P}e(t)}}+\underset{I}{\underbrace{K_{I}\int e(t)dt}}+\underset{D}{\underbrace{K_{D}\frac{d}{dt}e(t)}}\label{eq:PID-controller}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where the three coefficients 
\begin_inset Formula $K_{P}$
\end_inset

, 
\begin_inset Formula $K_{I}$
\end_inset

 and 
\begin_inset Formula $K_{D}$
\end_inset

 are used to tune the relative weights of the P, I and D terms.
 P and D resemble a damped spring where the spring exerts proportional force
 if it is stretched or compressed from its resting position and the velocity
 (rate of change in spring length) is used to damp the oscillations and
 quickly come to rest.
 The integral term is the sum of error over time and has the effect of gradually
 amplifying the error reduction if the error persists.
\end_layout

\begin_layout Subsubsection
Example of an autonomous train
\end_layout

\begin_layout Standard
Consider a modern train that is controlled by an autopilot.
 This example will show how this problem could be solved using a simple
 PID loop controller, odometer as sensor and throttle as the controlled
 device.
 For simplicity we assume the following:
\end_layout

\begin_layout Itemize
Throttle control value is clamped by 
\begin_inset Formula $u(t)\in\mathbb{R}\left[-1,1\right]$
\end_inset

where positive values accelerate forwards and negative values backwards.
\end_layout

\begin_layout Itemize
The train accelerates linearly as a function of throttle, given by 
\begin_inset Formula $a(u)=4u(t)$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
m/
\begin_inset Formula $s^{2}$
\end_inset

.
\end_layout

\begin_layout Itemize
The train suffers from friction as a linear function of velocity, given
 by 
\begin_inset Formula $f(v)=0.1v$
\end_inset

.
\end_layout

\begin_layout Itemize
The the train moves on rails so we only need to consider throttling in either
 direction.
\end_layout

\begin_layout Paragraph
P-controller
\end_layout

\begin_layout Standard
We will start by moving the train from A to B using only the P term.
 A is positioned at 0 meters and B at 100 meters and the initial error e(0)
 is -100m.
 
\begin_inset Formula $K_{p}$
\end_inset

 is chosen as 
\begin_inset Formula $\frac{-1}{100m}$
\end_inset

 so the throttle is immediately floored by the P term.
 When the train starts moving towards B the throttle is gradually relaxed
 and when we reach our destination the error becomes zero and the throttle
 is set to neutral.
 However, because the train has momentum it will overshoot B as figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:P-overshoot"

\end_inset

 shows and oscillate back and forth across B until the train eventually
 comes to rest due to the damping effect of friction.
 
\end_layout

\begin_layout Standard
The oscillating behavior it not desired since the passengers will pass the
 train station several times before stopping.
 Although friction already dampens the oscillation we would like to overdamp
 the function so we stop at B on the first attempt.
 The D-term provides the damping we need, so let us examine how it works.
\end_layout

\begin_layout Paragraph
PD-controller
\end_layout

\begin_layout Standard
With sufficiently large 
\begin_inset Formula $K_{D}$
\end_inset

 the D-term gradually relaxes the throttle and starts breaking as we are
 approaching B at a velocity.
 Let us keep 
\begin_inset Formula $K_{P}$
\end_inset

 and choose 
\begin_inset Formula $K_{D}=\frac{-1}{5m/s}$
\end_inset

.
 
\end_layout

\begin_layout Standard
It can be seen from figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:PD-no-overshoot"

\end_inset

 how the P coefficient is strong near the starting condition where the error
 is large and this accelerates the train quickly.
 Near 50 seconds the proportional error is starting to get small compared
 to the velocity and the effect of the D-term damping becomes dominant causing
 the train to slow down.
 The P-term will continue to 
\begin_inset Quotes eld
\end_inset

pull
\begin_inset Quotes erd
\end_inset

 the train towards B as a spring and the D-term will prevent the train from
 overshooting.
 
\end_layout

\begin_layout Standard
The train is now able to transport passengers smoothly from A to B because
 the coefficients are tuned for the behavior of this train, but what happens
 if the environment changes? Let us finally consider the I-term of the PID-contr
oller.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[P-controller: Train overshoots its destination.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/P_overshoot.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:P-overshoot"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[PD-controller: Train stops smoothly at its destination.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/PD_no_overshoot.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:PD-no-overshoot"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The effects of applying P and PD controllers with appropriately tuned coefficien
ts.
\begin_inset CommandInset label
LatexCommand label
name "fig:P-PD-PID-controllers"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
PID-controller
\end_layout

\begin_layout Standard
In a perfect world the PD coefficients would be chosen to fit each application
 and achieve perfect behavior.
 However, in the real world of non-deterministic processes this is not so.
 Windy conditions, wear and tear on mechanical parts and uphill slopes complicat
e the problem of choosing coefficients that get the train to its destination
 in a quick, accurate and smooth manner.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:PD-extra-friction"

\end_inset

 shows how an unforeseen increase in friction to 
\begin_inset Formula $f(v)=0.5v$
\end_inset

 results in a dramatic delay.
 In this particular case it prolongs the traveling time from 150 to 400
 seconds since the throttle is not applied efficiently.
 Note how the large friction alone is sufficient for the train to come to
 a stop so that the throttle never has to go negative.
\end_layout

\begin_layout Standard
The I-term sums the error in position over time and accelerates the reduction
 of error the longer the error persists.
 This means a good choice of 
\begin_inset Formula $K_{I}$
\end_inset

 will get the train to its destination more quickly if the train is starting
 to run late.
 
\begin_inset Formula $K_{P}$
\end_inset

 and 
\begin_inset Formula $K_{D}$
\end_inset

 must be reconfigured to avoid oscillating behavior introduced by the I-term,
 so we choose 
\begin_inset Formula $K_{P}=-1$
\end_inset

, 
\begin_inset Formula $K_{D}=-4$
\end_inset

 and 
\begin_inset Formula $K_{I}=\frac{1}{100000}$
\end_inset

.
 
\end_layout

\begin_layout Standard
It should be seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overcoming-dynamic-changes"

\end_inset

 how the throttle control is maxed by the P and I terms until the train
 nears its target at such a speed the D term begins to relax the throttle.
 As a result the travel time of the train has improved from 400 to 70 seconds
 with the same amount of friction.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[PD-controller: An increase in friction dramatically delays the
 train.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/PD_extra_friction.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:PD-extra-friction"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[PD-controller: The throttle is not used to its potential.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/PD_extra_friction_throttle.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:PD-extra-friction-throttle"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The PD controller may not suffice if the environment changes from what it
 was tuned for.
\begin_inset CommandInset label
LatexCommand label
name "fig:PID-environment"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
subfigure[PID-controller: The I-term accelerates the train to minimize the
 travel time]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/PID_extra_friction2.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:PID-extra-friction"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
subfigure[PID-controller: Throttle is more aggressive and overcomes the
 extra friction]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Graphs/PID_extra_friction_throttle.JPEG
	lyxscale 50
	height 6cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:PID-extra-friction-throttle-1"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Overcoming dynamic changes in the environment using a PID controller.
\begin_inset CommandInset label
LatexCommand label
name "fig:Overcoming-dynamic-changes"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although this is a very simple example the nature of PID controllers have
 proven very reliable and applicable to most control problems in the real
 world.
 The difficulty of PIDs are to choose good coefficients that perform satisfactor
y and for this we need methods to tune the coefficients.
\end_layout

\begin_layout Subsection
PID Tuning
\begin_inset CommandInset label
LatexCommand label
name "sub:PID-Tuning"

\end_inset


\end_layout

\begin_layout Standard
Before fiddling with the coefficients we should first realize that a PID-control
ler is not always the best fit.
 Getting all three PID coefficients to work in harmony is anything but trivial
 and we may successfully omit one or two to achieve better results.
 In 
\begin_inset CommandInset citation
LatexCommand cite
after "p. node63.html"
key "schmid05"

\end_inset

 the behavior of different controller types are discussed and figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Optimal-tuning-of"

\end_inset

 shows how they perform to each other in one particular scenario.
 Here the uncontrolled steady-state converges towards 
\begin_inset Formula $y_{\infty}=1$
\end_inset

 and the controller's target value is 
\begin_inset Formula $y_{ref}=0$
\end_inset

.
 The figure can be summarized as follows: 
\end_layout

\begin_layout Itemize
P-controller: high overshoot, long settling time and large steady-state
 error
\end_layout

\begin_layout Itemize
I-controller: highest overshoot, no steady-state error
\end_layout

\begin_layout Itemize
PI-controller: high overshoot, no steady-state error
\end_layout

\begin_layout Itemize
PD-controller: medium overshoot, medium steady-state error
\end_layout

\begin_layout Itemize
PID-controller: smallest overshoot, no steady-state error
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/pid_configurations.png
	lyxscale 50
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Comparison of P, I, PI, PD and PID controllers.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
after "p. node63.html"
key "schmid05"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Optimal-tuning-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
At first glance it would seem obvious that the PID-controller is superior
 to the other controllers, but that is not necessarily true for other scenarios.
 The fact is that PIDs are difficult to tune properly and with untuned coefficie
nts the controller will suffer from poor performance or go unstable.
 
\end_layout

\begin_layout Standard
For instance, if our top priority is minimal steady-state error then an
 I- or PI-controller may suffice or to achieve fast response a P or PD controlle
r might work well.
 The advantage with simpler controllers is that the coefficients are much
 easier to tune and to keep stable.
 So first we need to decide what the optimal response properties are, then
 choose a matching controller and finally tune the coefficients.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Autopilot-Logic"

\end_inset

 we explain how we use P-controllers to control the helicopter attitude,
 while the throttle required a PID-controller for stable altitude control.
\end_layout

\begin_layout Subsubsection
Trial and Error
\end_layout

\begin_layout Standard
The most straight forward method of tuning is to tweak each property and
 see if the result gets any better.
 The following 5 steps 
\begin_inset CommandInset citation
LatexCommand cite
key "copeland08"

\end_inset

 are the basis of manually tuning a PID controller:
\end_layout

\begin_layout Enumerate
Set 
\begin_inset Formula $K_{P}=K_{I}=K_{D}=0$
\end_inset

.
\end_layout

\begin_layout Enumerate
Increase 
\begin_inset Formula $K_{P}$
\end_inset

 until the output oscillates, then reduce the 
\begin_inset Formula $K_{P}$
\end_inset

 until the amplitudes reduce by approximately 75% each period.
\end_layout

\begin_layout Enumerate
Increase 
\begin_inset Formula $K_{I}$
\end_inset

 until any offset is corrected for within sufficient time.
\end_layout

\begin_layout Enumerate
Increase 
\begin_inset Formula $K_{D}$
\end_inset

 until the output converges to an acceptable error within sufficient time.
\end_layout

\begin_deeper
\begin_layout Enumerate
A speedy configuration use smaller values of 
\begin_inset Formula $K_{D}$
\end_inset

 and typically overshoots slightly to converge more quickly.
\end_layout

\begin_layout Enumerate
If overshoots are not acceptable (do not pass the train station) then increase
 until the output is sufficiently over-damped as seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:PD-no-overshoot"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Experiment by tweaking the values near this base setting to improve the
 result.
\end_layout

\begin_layout Standard
It is often required to manually fine-tune the PID and table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Effects-of-increasing-PID"

\end_inset

 summarizes the effects of the three coefficients.
 The controller can be sucessfully optimized using trial and error with
 a little bit of experience and knowing how these effects interact.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Rise time 
\begin_inset Formula $t_{r}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Overshoot 
\begin_inset Formula $M_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Settling time 
\begin_inset Formula $t_{\varepsilon}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Steady-state error
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $K_{P}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Increase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $K_{I}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Increase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Increase
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eliminates
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $K_{D}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decrease
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Effects of increasing PID coefficients.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "pid_tuning"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Effects-of-increasing-PID"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ziegler-Nichols Method 
\end_layout

\begin_layout Standard
Ziegler and Nichols derived a table based on their experience with trial
 and error that helps create a stable base setting for different controllers.
 Although the values are derived from assumptions on the environment model,
 this approach has been widely accepted in the industry as a standard in
 control systems practice.
 
\end_layout

\begin_layout Section
State Estimation
\begin_inset CommandInset label
LatexCommand label
name "sec:State-Estimation-Theory"

\end_inset


\end_layout

\begin_layout Standard
Now that we have a understanding of control theory and regulatory systems
 we need to provide a feedback to the autopilot controller logic.
 The feedback is typically the variables such as the position, velocity
 and orientation of the helicopter and this section discusses how to estimate
 these from incomplete and noisy sensor measurements.
\end_layout

\begin_layout Subsection
Flight Sensors
\begin_inset CommandInset label
LatexCommand label
name "sub:Flight-Sensors"

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Modern Control 9p
\end_layout

\begin_layout Plain Layout
Modern Control System Theory:
\end_layout

\begin_layout Plain Layout
http://books.google.no/books?id=busgee_YN3oC&lpg=RA1-PA113&ots=SbtIfQVevW&dq=Autor
egressive%20Model%20modern%20control&pg=RA1-PA120#v=onepage&q=&f=false
\end_layout

\begin_layout Plain Layout
Modern Control Systems: xix preface, PID (transfer function?), Root Locus
 Method (to design feedback control)
\end_layout

\begin_layout Plain Layout
http://books.google.no/books?id=V-FpzJP5bEIC&lpg=PA815&ots=EcfWE01eGH&dq=Autoregre
ssive%20Model%20modern%20control&pg=PP18#v=onepage&q=modern%20control&f=false
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Plant
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our implementation we use sensors to determine the current state of the
 helicopter and this subsection covers what state information is required
 for autonomous flight and what types of sensors are available to provide
 this.
 
\end_layout

\begin_layout Paragraph
State Information Required For Helicopter Maneuvering
\end_layout

\begin_layout Standard
The primary objective of our autopilot
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "autopilot"
description "Control logic designed to navigate a machine autonomously. "

\end_inset

 is to avoid crashing into the ground or into obstacles.
 We may also want it to navigate from A to B as long as that does not conflict
 with the first objective.
 To achieve either one we need to know at the very least where we are, where
 we are headed and how to control these two.
 
\end_layout

\begin_layout Standard
A simplified hierarchy of state information is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Hierarchy-of-control"

\end_inset

 and this illustrates how a chain of control may be applied for a helicopter
 autopilot.
 In the end the only means of maneuvering a helicopter is to apply thrust
 and cyclic, as discussed in 
\begin_inset CommandInset citation
LatexCommand cite
after "ch. 2.1"
key "a2ds_project"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/autopilot_control_chain.jpeg
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Hierarchy of information and chain of control for a helicopter autopilot.
\begin_inset CommandInset label
LatexCommand label
name "fig:Hierarchy-of-control"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The autopilot output is typically determined by a basic navigation state
 unless there are immediate dangers that override it.
 In order to navigate to B the autopilot must minimize the positional error
 and intuitively we can achieve this by controlling the velocity.
 The velocity is in turn a result of forces that act on the helicopter over
 time.
 Although we cannot control the environmental forces we are able to apply
 thrust and direct it using the cyclic to move towards B.
 
\end_layout

\begin_layout Standard
The same basic principles apply for any aircraft.
 Now that we have an understanding of what information is required for an
 autopilot to function we can look at what sensors exist to provide this.
\end_layout

\begin_layout Paragraph
Actual and Inferred Measures
\end_layout

\begin_layout Standard
We distinguish between two types of sensor output; actual and inferred.
 All sensors measure one or more physical properties directly such as relative
 air speed and altitude.
 However, most measurements can also infer extra information using mathematics
 and physics.
 The derivative and integral relationships between position, velocity and
 acceleration is well known, but the integration suffers from numerical
 diffusion.
 For instance, small errors in acceleration measurements have a large impact
 on positional estimates by dead-reckoning, because the errors are double-integr
ated over time.
\end_layout

\begin_layout Standard
A list of flight sensors relevant for autopilot systems are listed in table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:A-list-of-sensors"

\end_inset

.
 In general the quality of a sensor can be described by four properties:
 
\end_layout

\begin_layout Itemize
Accuracy: its ability to measure a physical property.
\end_layout

\begin_layout Itemize
Precision: its ability to numerically represent the measurement.
\end_layout

\begin_layout Itemize
Frequency: number of samples per second.
\end_layout

\begin_layout Itemize
Noise.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="center" valignment="top" width="3cm">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Measures
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Inferred Information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Altimeter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Height over a reference point
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Height over the ground
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3D Compass
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Relative magnetic field fluxes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Orientation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global position, velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Height over the ground
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range Finder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distance to nearest surface in a direction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Height over the ground, distance to obstacle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IMU
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "IMU"
description "Inertial Measurement Unit measures change in linear and angular motion."

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Acceleration, angular velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Position, velocity, orientation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flight sensor types; what they measure and what information can be inferred
\begin_inset CommandInset label
LatexCommand label
name "tab:A-list-of-sensors"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obviously we want to optimize these properties, but for a small airborne
 drone this is limited by cost, size and weight.
 This means we need to look at methods of estimating the state based on
 inaccurate, infrequent and noisy samples of the world and the Kalman filter
 is a good fit for just that.
 
\end_layout

\begin_layout Subsection
Kalman Filter
\begin_inset CommandInset label
LatexCommand label
name "sub:Kalman-Filter-Theory"

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Notater fra Aided Navigation boka 
\end_layout

\begin_layout Plain Layout
- Lider av numerisk feilakkumulasjon 
\end_layout

\begin_layout Plain Layout
- Kovarians matrise skal være symmetrisk => må ofte korrigeres ved f.eks.
 P = 0.5(P + P^T) 
\end_layout

\begin_layout Plain Layout
- A "truth model" kan ha opptil 100 states for et INS/GPS system, med 6
 states per satelitt.
 Vi gjør forenklinger, og den økte feilen pga.
 forenklet modell kan til en viss grad kompenseres på sparket ved å øke
 Q og R støymatrisene.
\end_layout

\begin_layout Plain Layout
- Linearized Kalman Filter => vi har en forhåndsbestemt path, og formulerer
 filteret som en feil i forhold til denne idelle pathen (vil ha error =>
 0) 
\end_layout

\begin_layout Plain Layout
- Extended KF => UAV har ikke en forhåndsbestemt path ved designfasen, linearise
rer på tilstand
\end_layout

\begin_layout Itemize
Ref: Google Books / kap 13.7 i Strapdown inertial navigation technology Av
 David H.
 Titterton,John L.
 Weston,Institution of Electrical Engineers
\end_layout

\begin_deeper
\begin_layout Itemize
Uncoupled: GPS simply resets INS error periodically
\end_layout

\begin_layout Itemize
I get this when zeroing GPS observations in K-matrix whenever GPS measurement
 is missing, trajectory jumps for each noisy GPS measurement
\end_layout

\begin_layout Itemize
Loosely coupled: deviation of GPS and INS estimate forms measurement of
 a Kalman Filter (nullifisering)
\end_layout

\begin_layout Itemize
Tightly coupled: pseudo range and pseudo range rate compared to estimates
 of these from INS
\end_layout

\begin_layout Itemize
Deep/Ultra tight: combine GPS signal tracking and GPS/INS integration in
 a single algorithm
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
The Kalman filter is a recurring choice in automation tasks due to its ability
 to fuse the information from multiple sensors by modelling the sensor propertie
s.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "welch06"

\end_inset

 the Kalman filter (KF
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "KF"
description "Kalman Filter"

\end_inset

) is described as a recursive stochastic technique that estimates the state
 of a dynamic system from a set of incomplete and noisy observations.
 In our case of navigation this can be used to estimate the helicopter position,
 velocity and orientation from unreliable sensor measurements in the world.
\end_layout

\begin_layout Standard
Formally, KF solves the problem of estimating a true state 
\begin_inset Formula $\mathbf{x}_{k}$
\end_inset

 that is governed by a linear stochastic difference equation
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{x}_{k}=\mathbf{A}_{k-1}\mathbf{x}_{k-1}+\mathbf{B}_{k}\mathbf{u}_{k}+\mathbf{w}_{k},\label{eq:KF-controlled-process-state}\end{equation}

\end_inset

given an observation 
\begin_inset Formula $\mathbf{z}_{k}$
\end_inset

 per state by 
\begin_inset Formula \begin{equation}
\mathbf{z}_{k}=\mathbf{H}_{k}\mathbf{x}_{k}+\mathbf{v}_{k}.\label{eq:KF-observation}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Description-of-the-KF-symbols"

\end_inset

 summarizes the symbols.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:KF-overview"

\end_inset

 illustrates how the real state 
\begin_inset Formula $\mathbf{x}$
\end_inset

 is hidden from us and we see the that the following information is available:
\end_layout

\begin_layout Itemize
We define a state transition model 
\begin_inset Formula $\mathbf{A}_{k-1}$
\end_inset

 for how we expect the previous state 
\series bold

\begin_inset Formula $\mathbf{x}_{k-1}$
\end_inset

 
\series default
to propagate on its own with no control input.
\end_layout

\begin_layout Itemize
We know the current autopilot output 
\begin_inset Formula $\mathbf{u}_{k}$
\end_inset

 and define a control model 
\begin_inset Formula $\mathbf{B}_{k}$
\end_inset

 of how that output is expected to change the state.
\end_layout

\begin_layout Itemize
We observe the current true state 
\begin_inset Formula $\mathbf{x}_{k}$
\end_inset

 as 
\begin_inset Formula $\mathbf{z}_{k}$
\end_inset

 and define an observation model 
\begin_inset Formula $\mathbf{H}_{k}$
\end_inset

 that transforms the state to the respective observations.
\end_layout

\begin_layout Itemize
The process noise 
\begin_inset Formula $\mathbf{w}$
\end_inset

 and the observation noise 
\begin_inset Formula $\mathbf{v}$
\end_inset

 can be modelled if their statistical distributions are known.
\end_layout

\begin_layout Standard
It has been proven 
\begin_inset CommandInset citation
LatexCommand cite
key "jazwinski70"

\end_inset

 that KF estimates a state with minimum mean square error for linear systems
 given that:
\end_layout

\begin_layout Enumerate
The process model noise is white and Gaussian with distribution 
\begin_inset Formula $\mathbf{w}\sim\mathcal{N}(0,\mathbf{Q})$
\end_inset

.
\end_layout

\begin_layout Enumerate
The observation model noise is white and Gaussian with distribution 
\begin_inset Formula $\mathbf{v}\sim\mathcal{N}(0,\mathbf{R})$
\end_inset

.
\end_layout

\begin_layout Enumerate
The two are independent of each other.
\end_layout

\begin_layout Enumerate
The initial condition (initial estimated state) is set to the actual initial
 system state excluding process noise.
\end_layout

\begin_layout Standard
In other words, KF provides an optimal guess of the current flight state
 given a reliable starting point and unreliable flight sensor data up to
 that point.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/KalmanFilter_estimation.jpeg
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
System states 
\begin_inset Formula $\mathbf{x}$
\end_inset

, control inputs 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and state observations 
\begin_inset Formula $\mathbf{z}$
\end_inset

.
 Noise is omitted for clarity.
\begin_inset CommandInset label
LatexCommand label
name "fig:KF-overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="6cm">
<column alignment="center" valignment="top" width="6cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
General Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Contextual Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{A}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State transition model that evolves a state by its underlying process model
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equations that govern world physics
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{B}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Control model that maps control input into changes in true state space
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equations that map autopilot output to changes in helicopter state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{u}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Control input vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Autopilot output in terms of pitch, roll, yaw and thrust
\end_layout

\end_inset
</cell>
</row>
<row newpage="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{H}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Observation model that maps true state space into observed space
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equations that map helicopter position, velocity and orientation to respective
 sensor measurements
\end_layout

\end_inset
</cell>
</row>
<row newpage="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathbf{w}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Process noise
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The world physics is not entirely represented by the modelled state transition
 A
\end_layout

\end_inset
</cell>
</row>
<row newpage="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\mathbf{v}_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Observation noise
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Noise in the observations due to sensor precision and accuracy
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Description of the symbols in equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-controlled-process-state"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-observation"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Description-of-the-KF-symbols"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Prediction
\end_layout

\begin_layout Standard
The KF algorithm is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "welch06"

\end_inset

 as having two steps and is illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:KF-The-two-steps"

\end_inset

.
 The first step calculates a predicted (a priori) next state 
\begin_inset Formula $\mathbf{\hat{x}}_{k}^{-}$
\end_inset

 from its previous estimated state 
\begin_inset Formula $\mathbf{\hat{x}}_{k-1}$
\end_inset

 based on how we have modelled the state to propagate on its own
\series bold
 
\series default
(state transition model 
\begin_inset Formula $\mathbf{A}_{k-1}$
\end_inset

) and how the current autopilot output will affect the next state (control
 model 
\begin_inset Formula $\mathbf{B}_{k}$
\end_inset

 and control input 
\begin_inset Formula $\mathbf{u}_{k}$
\end_inset

) from equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-controlled-process-state"

\end_inset

.
 This prediction, as one can see, is made without any observations and simply
 follows the modelled process.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\hat{\mathbf{x}}_{k}^{-} & = & \mathbf{A}_{k-1}\hat{\mathbf{x}}_{k-1}+\mathbf{B}_{k}\mathbf{u}_{k}\label{eq:KF-predicted-estimate-state}\\
\mathbf{P}_{k}^{-} & = & \mathbf{A}_{k-1}\mathbf{P}_{k-1}\mathbf{A}_{k-1}^{T}+\mathbf{Q}_{k}\label{eq:KF-predicted-estimate-covariance}\end{eqnarray}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\hat{\mathbf{x}}_{k}^{-}$
\end_inset

 Predicted state estimate based on the previous state estimate, the previous
 control input and the known process model.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{P}_{k}^{-}$
\end_inset

 Predicted estimate covariance describes the uncertainty of the predicted
 estimate.
\end_layout

\begin_layout Paragraph
Correction
\end_layout

\begin_layout Standard
When the system enters state 
\begin_inset Formula $k$
\end_inset

 an (unreliable) observation 
\begin_inset Formula $\mathbf{z}_{k}$
\end_inset

 is made.
 This observation is then used to correct the former prediction of the state
 and establish a corrected (a posteriori) estimate 
\begin_inset Formula $\mathbf{\hat{x}}_{k}$
\end_inset

.
 An important part of the correction step is to compute a 
\emph on
Kalman gain
\emph default
 
\begin_inset Formula $\mathbf{K}_{k}$
\end_inset

 that minimizes the covariance of the mean squared estimate error.
 The gain can be considered a weighting function that balances its trust
 between the predicted state 
\begin_inset Formula $\mathbf{\hat{x}}_{k}^{-}$
\end_inset

 and the observation 
\begin_inset Formula $\mathbf{z}_{k}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\tilde{\mathbf{y}}_{k} & = & \mathbf{z}_{k}-\mathbf{H}_{k}\hat{\mathbf{x}}_{k}^{-}\\
\mathbf{S}_{k} & = & \mathbf{H}_{k}\mathbf{P}_{k}^{-}\mathbf{H}^{T}+\mathbf{R}_{k}\\
\mathbf{K}_{k} & = & \mathbf{P}_{k}^{-}\mathbf{H}^{T}\mathbf{S}_{k}^{-1}\\
\hat{\mathbf{x}}_{k} & = & \hat{\mathbf{x}}_{k}^{-}+\mathbf{K}_{k}\tilde{\mathbf{y}}_{k}\\
\mathbf{P}_{k} & = & (\mathbf{I}-\mathbf{K}_{k}\mathbf{H}_{k})\mathbf{P}_{k}^{-}\end{eqnarray}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\tilde{\mathbf{y}}_{k}$
\end_inset

 Innovation of the observation versus the expected observations for the
 predicted state.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{S}_{k}$
\end_inset

 Covariance of innovation.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}_{k}$
\end_inset

 Optimal Kalman gain describes its distribution of trust between the predicted
 state and the observed state.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{\hat{x}}_{k}$
\end_inset

 Corrected state estimate is the final estimate for state 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{P}_{k}$
\end_inset

 Corrected estimate covariance is the uncertainty for estimated state 
\begin_inset Formula $\hat{\mathbf{x}}_{k}$
\end_inset

.
\end_layout

\begin_layout Standard
See in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:KF-The-two-steps"

\end_inset

 how the first step predicts the next state prior to observation and then
 later corrects this estimate by the error between predicted and observed
 values.
 The corrected value is then used to predict the next state and so it continues
 cyclically.
 The iterative operation of the two steps and the background for these equations
 are covered in detail in 
\begin_inset CommandInset citation
LatexCommand cite
key "welch06"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "jazwinski70"

\end_inset

.
 Note that there are some differences in how the index 
\begin_inset Formula $k$
\end_inset

 is applied depending on the models.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/KF_two_steps.jpg

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The two steps in the Kalman filter operation.
 A and H are shown as constants here.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "welch06"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:KF-The-two-steps"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Kalman Filter in Practice
\end_layout

\begin_layout Standard
The motivation for using KF is to achieve reliable estimates from noisy
 and incomplete data.
 This section presents an example where the 2D position of an object is
 being tracked by a positioning sensor.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Measured-position-as"

\end_inset

 shows the position observations as red dots along the real path of the
 object.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/KF_position_measure.jpg
	lyxscale 50
	width 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Measured position as dots and actual path as a curved line.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "cosy08"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Measured-position-as"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "Flo:KF-position-estimate"

\end_inset

 shows how the filter is able to crudely match its estimates with the real
 trajectory and it is a huge improvement over the original plots with significan
tly less noise.
 But it should also be seen that the path generated by the Kalman filter
 is still very rugged and the sudden changes in estimated velocity would
 probably cause the controller to become jittery.
 Smoothing the estimates would help, but autonomous vehicles need to navigate
 based on the most recent estimate so any smoothing is restricted to the
 history of estimates.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/KF_position_estimate2.png
	lyxscale 50
	width 12cm

\end_inset

 
\begin_inset Caption

\begin_layout Plain Layout
Estimated position using Kalman filter.
 Source: 
\begin_inset CommandInset citation
LatexCommand cite
key "cosy08"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "Flo:KF-position-estimate"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obviously there is no substitute for more accurate sensor data, but the
 Kalman filter does a good job in filling the gap.
 It has proven valuable in minimizing the estimate error and fusing overlapping
 information from several sensor types to more accurately estimate information
 about the state.
 In particular, 
\begin_inset CommandInset citation
LatexCommand cite
key "gpsimu_fusion06"

\end_inset

 discusses how an inertial measurement unit (IMU) and a GPS may be combined
 in a Kalman filter to more accurately estimate the position.
 The IMU has a high accuracy in temporal motion but tends to drift over
 time, while the GPS is infrequent and inaccurate but provides absolute
 measurements that counter the drift.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Impl"

\end_inset

 we discuss how we implemented a GPS/INS Kalman filter for the helicopter
 state estimation.
\end_layout

\begin_layout Paragraph
Non-Linear Systems 
\end_layout

\begin_layout Standard
The Kalman filter is limited to linear systems and will perform poorly otherwise.
 There are a number of variations that try to linearize the problem such
 as the Extended Kalman Filter, Unscented Kalman Filter and Potter Square
 Root Filter, but we will not cover them here.
 As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Impl"

\end_inset

 we did not have time to add orientation estimation to the Kalman filter
 and omitted the problem of non-linearity in our implementation.
\end_layout

\begin_layout Chapter
Implementation
\begin_inset CommandInset label
LatexCommand label
name "cha:Implementation"

\end_inset


\end_layout

\begin_layout Standard
This section covers all the important aspects of our implementation.
 An autopilot simulator is very comprehensive and involves physics simulation,
 virtual sensors, autopilot logic and visualization techniques.
 In this section we discuss each part and the software architecture that
 tie these components together.
\end_layout

\begin_layout Section
Dependencies
\end_layout

\begin_layout Standard
We used a number of freely available code libraries to aid in the development
 and the following are required for the simulator to compile and run.
 
\end_layout

\begin_layout Paragraph
XNA Game Studio 3.1
\end_layout

\begin_layout Standard
XNA Game Studio (EULA) is a framework and a set of tools to help develop
 2D and 3D games on the Microsoft platform; including PC, Xbox 360 and Zune.
 The XNA framework is a managed code wrapper for the DirectX API and makes
 it easy to use DirectX from managed code languages such as C# and Visual
 Basic.
 Managed code simplifies the development process since the allocated resources
 are automatically garbage collected and there are powerful refactoring
 tools available to help maintain the code.
 
\end_layout

\begin_layout Paragraph
Math.NET Iridium v2008.8.16.470
\end_layout

\begin_layout Standard
Iridium (LGPL license) is a math library that offers basic numerics, linear
 algebra, random generators and more.
 In our implementation we used Iridium to perform matrix operations in the
 Kalman filter.
 
\end_layout

\begin_layout Paragraph
NUnit 2.5.3
\end_layout

\begin_layout Standard
NUnit (BSD license) is an open source unit testing framework for all .NET
 languages and was originally ported from JUnit for Java.
 We used NUnit to create unit tests in our implementation in order to ensure
 the correctness of pieces of code.
 
\end_layout

\begin_layout Paragraph
Swordfish Charts 0.6
\end_layout

\begin_layout Standard
Swordfish charts (BSDlicense) were used for dynamic graphing and illustrating
 flight trajectories of the helicopter.
 This .NET graphing tool uses WPF vectorized graphics and allows one to zoom
 without rasterization artifacts.
 
\end_layout

\begin_layout Paragraph
Jitter Physics Engine 0.1.0 (beta)
\end_layout

\begin_layout Standard
Jitter (free for non-commercial use) is a lightweight .NET managed physics
 engine that is designed for use in .NET and XNA.
 The engine originates from the widely used open source JiglibX library
 and has been extended with new features.
 Jitter is not open source, but is free to use for non-commercial applications.
 In our implementation we use Jitter to handle collisions between the helicopter
 and the terrain to prevent the helicopter from flying through the ground
 and to enable the helicopter to land.
\end_layout

\begin_layout Paragraph
VrpnNet 1.1.1
\end_layout

\begin_layout Standard
The Virtual Reality Peripheral Network (VRPN) (MIT license) 
\begin_inset CommandInset citation
LatexCommand cite
key "vrpn"

\end_inset

 is a public-domain software released by the University of North Carolina.
 The software includes both server and client and allows for easy retrieval
 of virtual reality sensor data over a network.
 VrpnNet is a library that allows .NET applications to easily interface with
 VRPN and the connected sensors.
\end_layout

\begin_layout Section
Software Architecture
\begin_inset CommandInset label
LatexCommand label
name "sec:Software-Architecture"

\end_inset


\end_layout

\begin_layout Standard
When designing the software architecture we needed to consider the major
 concerns for the quality of the software.
 A good architecture not only eases the effort of working with the code,
 but also promotes desired system qualities that is considered important
 for the overall quality.
 In this section we will identify key requirements and tactics and give
 an overview of the architecture we used for our implementation.
\end_layout

\begin_layout Subsection
Requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Requirements"

\end_inset


\end_layout

\begin_layout Standard
Being a thesis the implementation was subject to future extensions and reuse
 so 
\emph on
modifiability
\emph default
 was a big concern.
 Also the application was intended to run a real-time simulation so 
\emph on
performance
\emph default
 was an obvious concern.
 Finally the implementation was intended for future use in embedded systems
 so we also needed to account for 
\emph on
portability.
 
\emph default
We
\emph on
 
\emph default
isolated a few key quantitative and qualitative requirements to identify
 tactics and promote the three aspects of the software.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0.7cm">
<column alignment="left" valignment="top" width="14cm">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Requirement Description
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
It should be easy to add new sensor types and modify sensor configurations.
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The physics simulation should be replaceable and easy to modify.
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modifying the autopilot behavior should not affect other components.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Modifiability requirements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="left" valignment="top" width="0.7cm">
<column alignment="left" valignment="top" width="14cm">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Requirement Description
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simulation should run at interactive frame rates (> 10 fps) on the test
 computer setup
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Computer-Configuration"

\end_inset

 for details.
\end_layout

\end_inset

 .
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sensors should be able to run at different sampling rates up to 100 Hz.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Performance requirements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="left" valignment="top" width="0.7cm">
<column alignment="left" valignment="top" width="14cm">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Requirement Description
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The autopilot code and its dependencies can be written in the programming
 language C.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Portability requirements.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All requirements were satisfied in the implementation except for R5.
 It was problematic to simulate high-rate sensors and sensors running at
 different rates than the game loop.
 This is explained in detail section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Sampling-Rate"

\end_inset

.
\end_layout

\begin_layout Subsection
Tactics
\begin_inset CommandInset label
LatexCommand label
name "sub:Tactics"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features>
<column alignment="left" valignment="top" width="0.7cm">
<column alignment="left" valignment="top" width="2.5cm">
<column alignment="left" valignment="top" width="11cm">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Req.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tactic Description
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1,R2,R6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loose coupling by unified interface
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1,R2,R3,R6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minimize simulator dependencies
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R2,R3,R6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High cohesion by grouping code into package assemblies
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minimize platform specific dependencies (.NET and XNA)
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R1, R2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Use inheritance for variations of the same component type
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run updates separately from rendering in game loop
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Tactics to promote modifiability, performance and portability.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Not all requirements can be solved by architectural tactics.
 R4 is typically limited by the render pipeline for outdoor scenes and so
 the frame rate will be controlled by adjusting the number of scene objects
 and their detail levels.
 
\end_layout

\begin_layout Subsection
Trade-Offs
\end_layout

\begin_layout Standard
The most significant trade-off in our architecture tactics is compromising
 performance to gain modifiability and portability.
 There is some overhead in boxing and unboxing data structures for each
 method call and loosely coupled code as promoted by tactics T1 and T3 have
 longer call stacks and will suffer slightly in performance from this.
 Calling methods through interfaces and virtual methods as proposed by T1
 and T5 and converting .NET and XNA types to portable primitives as proposed
 by T4 will also introduce some overhead.
 However, we consider the final performance hit negligible for our simulation
 purposes and that the gains in modifiability and portability justify the
 costs.
 
\end_layout

\begin_layout Subsection
Reference Architecture
\end_layout

\begin_layout Standard
There a number of major patterns for robot architecture patterns, including
 
\emph on
control loop 
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "Lozano90"

\end_inset

, 
\emph on
layered
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "elfes"

\end_inset

and 
\emph on
blackboard
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Shafer86"

\end_inset

.
 Each pattern also has a number of widely used reference architectures to
 inspire the design.
 The main advantage of blackboard over layered was efficiency by parallel
 processing, which was not relevant to us, so we chose a combination of
 control loop and layered patterns.
 
\end_layout

\begin_layout Standard
The layered pattern was used as an overall architectural design to separate
 components into abstraction levels.
 Elfes 
\begin_inset CommandInset citation
LatexCommand cite
key "elfes"

\end_inset

 is one widely used reference architecture, illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Elfes-reference-architecture"

\end_inset

.
 The mapping from Elfes to our implementation is also shown in the figure
 where each layer lists its corresponding classes.
 It can be seen that we deviated slightly from the reference in that our
 Autopilot spans both Supervisor and Global Planning layers and that OutputContr
oller spanned Control and Navigation layers.
 This was mainly due to the smaller size of the implementation and it did
 not make sense to add the extra levels of abstraction.
 
\end_layout

\begin_layout Standard
The layered architecture allows one to reuse layers in future variations
 of the autopilot and to comply with standard interfaces for interoperability
 with off-the-shelf components.
 Any code changes are isolated to within individual layers and this is a
 good fit for requirement R3.
 On the downside it can be difficult to establish a correct granularity
 of layers and to decide what components belong to each layer.
 Also, once the architecture is designed it can be problematic to later
 redefine the behavior of a layer as there are a number of dependencies
 that rely on it.
\end_layout

\begin_layout Standard
A variation of the control loop pattern was already described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Direct-Digital-Control"

\end_inset

 and figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Direct-Digital-Control"

\end_inset

 illustrates how a controller computes output from input.
 We used the control loop pattern in our OutputController component, where
 input was the measured world state and output was the joystick output computed
 by the navigation logic and PID controllers.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Architecture/Elfes.png
	width 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Elfes reference architecture.
\begin_inset CommandInset label
LatexCommand label
name "fig:Elfes-reference-architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Class Diagram
\end_layout

\begin_layout Standard
The final architectural design is illustrated by a class diagram and a component
 data flow diagram in figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Class-diagram-of"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Component-data-flow"

\end_inset

.
 The class diagram shows how we divided key components into separate packages
 to preserve high cohesion as dictated by tactic T3.
 Tactic T1 is achieved by interfaces for state providers, physics components
 and sensors.
 Tactic T2 is achieved by using PhysicalHeliState as the coupling between
 our physics simulation and the portable SensorEstimatedState state estimator.
 The remaining tactics are implementation details and not illustrated here.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement p
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename UML/class_diagram.png
	lyxscale 50
	height 24cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Class diagram highlighting the coupling of key components and their packages.
\begin_inset CommandInset label
LatexCommand label
name "fig:Class-diagram-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Component Data Flow Diagram
\end_layout

\begin_layout Standard
The data flow can be considered cyclic since it runs in a game loop.
 Starting with the autopilot, figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Component-data-flow"

\end_inset

 shows how the autopilot has an initial guess of its current state.
 Depending on the state the autopilot decides how to issue joystick output
 to maneuver the helicopter.
 Optionally the autopilot can be overridden and flown manually by joystick.
 The joystick output is then input to our helicopter physics, which uses
 a flight dynamics model and collision handling to decide the new helicopter
 state at the end of the timestep.
 At this point the renderer will draw the helicopter at its current position
 and orientation.
 
\end_layout

\begin_layout Standard
Now that we have simulated the timestep we can simulate the sensors.
 For the state estimator to be synchronized with the physics simulation
 we must provide inertial measurements from the start of the timestep and
 GPS measurements from the end of the timestep.
 This way the GPS/INS Kalman filter can predict the change in state based
 on the IMU and correct the estimated state based on the GPS observations.
 The estimated state is then fed back into the autopilot and this concludes
 the cycle, which is repeated over and over.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Architecture/component_data_flow.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Component data flow.
\begin_inset CommandInset label
LatexCommand label
name "fig:Component-data-flow"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Visualization
\end_layout

\begin_layout Standard
To give a believable illusion of flying in the virtual world we implemented
 some visualization methods on our own and reused some open source components.
 This section covers the most significant parts of our implementation that
 were involved in the visualization.
 
\end_layout

\begin_layout Subsection
Skydome and Sunlight
\begin_inset CommandInset label
LatexCommand label
name "sub:Skydome-and-Sunlight"

\end_inset


\end_layout

\begin_layout Standard
The skydome and the sunlight effect were reused from the open source component
 Atmospheric Scattering V2 
\begin_inset CommandInset citation
LatexCommand cite
key "xna_skydome"

\end_inset

 to give the illusion of a sky surrounding the terrain.
 In contrast to typical skyboxes and skydomes there was no geometry involved
 in rendering the sky.
 Instead a HLSL
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "HLSL"
description "High Level Shader Language"

\end_inset

 shader was used to render the sky directly, which was very quick and produced
 believable results.
 The effect was largely based on blending color gradients between day, sunset
 and night as well as rendering a sun according to the time of day.
 The skydome component allowed us to easily manipulate the time of day by
 changing the parameters of the shader accordingly as shown in figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Screenshot-of-sunset"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Screenshot-of-daylight"

\end_inset

.
\end_layout

\begin_layout Standard
The same shader could also with some modifications be applied to scene objects
 to light them according to the color, intensity and direction of the sunlight.
 For outdoor scenes this is an important illusion since the sun is the main
 light source, so if the objects are not lit in the same manner this will
 look very unnatural.
 Finally, the shader used fog in order to blend the scene objects nicely
 into the horizon at long distances and at sunset this gave an illusion
 of atmospheric scattering, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Screenshot-of-sunset"

\end_inset

.
 
\end_layout

\begin_layout Standard
Since we were rendering outdoor scenes this sunlight effect was reused for
 all our scene objects to give a more natural appearance.
 The major modifications we needed to apply was concerned with objects that
 were already using shaders, such as the terrain and the trees.
 Those changes are described in their respective sections.
 For all other textured static mesh objects we created a SimpleModel class
 that applied the sunlight automatically.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/terrain_with_trees.jpg
	lyxscale 25
	width 13cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Screenshot of the world at sunset.
\begin_inset CommandInset label
LatexCommand label
name "fig:Screenshot-of-sunset"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/terrain_with_trees_daylight.jpg
	lyxscale 25
	width 13cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Screenshot of the world in daylight.
\begin_inset CommandInset label
LatexCommand label
name "fig:Screenshot-of-daylight"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Helicopter
\end_layout

\begin_layout Standard
Although most simple objects in the world were rendered by the SimpleModel
 class there were some objects that required more work.
 For instance the helicopter needed to let the rotor to spin and we also
 needed a 
\begin_inset Quotes eld
\end_inset

ghost
\begin_inset Quotes erd
\end_inset

 version of the helicopter that illustrated the position and rotation of
 the estimated helicopter state to help debug the autopilot.
\end_layout

\begin_layout Paragraph
Main Rotors
\end_layout

\begin_layout Standard
To give the illusion of the rotors rotating we split the mesh in two parts.
 In 3D Studio the rotor polygons were separated from the body to form two
 separate meshes
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "Static Mesh"
description "Polygon mesh without animation."

\end_inset

.
 The two meshes were named accordingly so that in XNA we could distinguish
 the two meshes by name.
 
\end_layout

\begin_layout Standard
XNA has classes for working with quaternions and the rotation of the helicopter
 is represented by a quaternion.
 Applying rotation to the rotors was then a matter of quaternion multiplication
 of helicopter rotation and local rotor rotation.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Applying-local-rotor-rotation"

\end_inset

 illustrates how the rotors are rotated as a function of time and how motion
 blur instances are positioned to give the illusion that the rotors are
 moving very fast.
 This effect is illustrated by 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rotor-motion-blur"

\end_inset

 where the opacity is gradually reduced for each successive motion blur
 instance.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
i = 0 to motionBlurCount
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $rotorBaseAngle=revolutionsPerSecond\cdot2\pi\cdot dt$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $localRotorAngle=rotorBaseAngle+i\cdot motionBlurSpacing$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $localRotorRotation=CreateQuaternionFromAxisAngle(Vector3.Up,\, localRotorAngle)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $worldRotorRotation=worldHelicopterRotation\times localRotorRotation$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Algorithm for applying local rotor rotation to the rotor mesh and rendering
 motion blur instances of the rotors.
\begin_inset CommandInset label
LatexCommand label
name "alg:Applying-local-rotor-rotation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/rotor_motion_blur.jpg
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An illusion of motion blur is achieved by rendering gradually more transparent
 rotor instances.
\begin_inset CommandInset label
LatexCommand label
name "fig:Rotor-motion-blur"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Helicopter Ghost
\end_layout

\begin_layout Standard
To aid in the debugging we needed to visualize the estimated state of the
 helicopter.
 By rendering the helicopter a second time with some specific render states
 we achieved a ghost-like effect.
 As seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Ghost-helicopter"

\end_inset

, the helicopter is transparent and white and this way we could easily see
 the errors in estimation alongside the real helicopter and clearly distinguish
 the two.
 These are the render states we set prior to rendering the helicopter with
 its normal render states.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

GraphicsDevice.RenderState.AlphaBlendEnable = true;
\end_layout

\begin_layout Plain Layout

GraphicsDevice.RenderState.SourceBlend = Blend.One;
\end_layout

\begin_layout Plain Layout

GraphicsDevice.RenderState.DestinationBlend = Blend.One;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/helicopter_ghost.png
	lyxscale 25
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
State estimation error visualized by a ghost helicopter.
\begin_inset CommandInset label
LatexCommand label
name "fig:Ghost-helicopter"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Terrain
\end_layout

\begin_layout Standard
For terrain we used an open source heightmap generator from an article on
 terrain generation 
\begin_inset CommandInset citation
LatexCommand cite
key "xna_terrain"

\end_inset

 and wrote a custom shader to render it.
 The shader blends textures of snow, grass, stones and dirt as a function
 of terrain height and adds the sun lighting as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Skydome-and-Sunlight"

\end_inset

.
 The end result is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Screenshot-of-sunset"

\end_inset

.
 Although the visualization is far from realistic it is easy on the eye
 and provides a believable representation of terrain.
 Even so, we would like to see more realistic details in the diffuse and
 heightmap textures as well as add bump mapping or parallax mapping to up
 the realism and the sense of scale.
\end_layout

\begin_layout Subsection
Trees
\begin_inset CommandInset label
LatexCommand label
name "sub:Trees"

\end_inset


\end_layout

\begin_layout Standard
Trees were rendered by the open source XNA component LTree 2.0a 
\begin_inset CommandInset citation
LatexCommand cite
key "xna_ltree"

\end_inset

.
 The component generated trees by the Lindenmayer system and utilized the
 XNA content pipeline to easily generate different kinds of trees from XML
 definition files.
 The component had a custom shader to render the trunk and branches as geometry
 and the leaves as billboards.
 The shader also supported simple skeleton animation to give the illusion
 of the trees swaying in the wind.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Trees don't work in latest version.
 Consider fixing.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The shader had to be modified to support our sunlight effect.
 The geometry shader was straight forward to modify, but the billboard shader
 was harder to get right.
 The problem was that the billboards are flat and always rotate to face
 the camera.
 In order to give the illusion of geometric leaves being lit by the sun
 we made a simplification where we constructed a normal vector directed
 towards the camera for each leaf billboard.
 This way when observing the tree from its shadow side it would look unlit
 and when observing it from towards the sunlit side it would gradually look
 more lit as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-sunlit-tree"

\end_inset

.
 Naturally, this uniform lighting of all the leaves did not look very realistic.
 However, as figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Screenshot-of-sunset"

\end_inset

 shows the sunlight effect did blend the trees naturally in with the rest
 of the sunlit terrain at distances.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/tree_lighting_comparison.png
	lyxscale 50
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
A sunlit tree seen from different angles.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-sunlit-tree"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Stereo Rendering
\end_layout

\begin_layout Standard
We decided to implement stereo rendering to give the user a heightened sense
 of depth in the virtual world.
 This was not only useful to better determine distances and the scale of
 things, but it was also very fun to use.
 In the lab we had a head mounted display (HMD) with head tracking and dual
 high-resolution monitors that were used to try out the stereo rendering
 effect.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
The implementation was fairly straight-forward as we already had camera
 classes providing the camera position, the look-at position and the up
 vector.
 Extending the camera implementations was simply a matter of rendering the
 world twice to different monitors and offsetting the camera position slightly
 according to the eye separation distance.
 We also had to take the up vector into account for rolling cameras such
 as the cockpit camera that utilized head tracking.
 The camera offsets would then be set along an axis perpendicular to the
 look-at vector and the up vector.
 
\end_layout

\begin_layout Paragraph
Eye Separation Distance
\end_layout

\begin_layout Standard
For a realistic 3D effect the camera offsets should match the true eye separatio
n distance.
 This distance can vary a few centimeters between persons, but an average
 for men is about 6.5 cm.
 We experimented with different values to see how they affected the 3D effect.
 In our implementation we used 10 cm, because it increased the 3D experience
 and was still comfortable to use.
 Beyond 10 cm we started noticing how it was hard to focus on different
 parts of the picture and how we could sustain only short periods of time
 before tiring and starting to get headaches.
 We experimented with values as high as 50 cm and could see parts of the
 picture clearly, but due to the focus depth nearer and more distant objects
 were hard to focus on.
\end_layout

\begin_layout Paragraph
Focus Point
\end_layout

\begin_layout Standard
In our implementation we used a look-at point fixed at a 10 meter distance
 from the camera.
 This meant that objects near that point would be clear, while objects away
 from that point would be harder to focus on.
 This issue became more evident when increasing the eye separation distance.
 We realized that there were two reasons to why stereo rendering was hard
 to get right.
\end_layout

\begin_layout Enumerate
\paragraph_spacing other 0.5
\noindent
The cameras must focus on what the user is looking at.
\end_layout

\begin_layout Enumerate
\paragraph_spacing other 0.5
\noindent
Everything else should to some degree be out of focus.
\end_layout

\begin_layout Standard
The first issue could be solved by a dynamic look-at point so that both
 eye cameras point towards what user is looking at.
 A simple solution would be to cast a ray along the non-stereo look-at vector
 and use the intersection point as a focus point for the stereo cameras.
 This would focus the cameras towards the nearest object roughly in the
 centre of the image.
 The problem was that the method does not take into account what part of
 the picture the user is looking at.
 Even with head-tracking and HMD some of the stereo illusion was lost since
 objects are harder to focus on if looking at areas off the picture centre.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/FocusPoint.png
	lyxscale 50
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Objects near the focus point become clear, while objects away from the point
 are harder to focus on.
\begin_inset CommandInset label
LatexCommand label
name "fig:Focus-Point"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We could prevent this artifact to some extent by applying the depth-of-field
 effect commonly used in modern games.
 If a dynamic look-at point was used then we could use a fast post-processing
 depth of field shader that blurs out the parts of the image that is out
 of focus.
 This way the out of focus effect on objects off the image center would
 not be as evident and it guides the focus of the user towards the center
 of the image.
 Unfortunately we did not have enough time to implement this.
\end_layout

\begin_layout Paragraph
Cross-Converged View
\end_layout

\begin_layout Standard
Since we already had the the code to render in stereo it was a short step
 to implement what is known as cross-converged viewing.
 The same effect is often used in 3D-image books and the advantage is that
 no special equipment or multiple monitors are required.
 The method is to render two cameras onto the same monitor by dividing the
 monitor in a left and right half as illustrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cross-converged-viewing"

\end_inset

.
 To achieve the stereo effect the user will cross his or her eyes by focusing
 on a point between the person and the monitor.
 With some exercise the two images will slide to form a third picture in
 the center, which comes into focus with the stereo effect.
 It helps to use the hands to cover the peripheral vision so that only the
 center image is visible.
 Unfortunately this method is very straining on the eyes and the horizontal
 field of view is halved.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/a2ds_001_left_half.jpg
	lyxscale 20
	width 7.5cm

\end_inset


\begin_inset Graphics
	filename Figures/Screenshots/a2ds_001_right_half.jpg
	lyxscale 20
	width 7.5cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Stereoscopic effect on single monitor by cross-converged viewing.
\begin_inset CommandInset label
LatexCommand label
name "fig:Cross-converged-viewing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cockpit Camera
\end_layout

\begin_layout Standard
Since we already had an HMD that supported head tracking we decided to create
 a cockpit camera.
 This allowed the user to fly the helicopter while sitting in a virtual
 3D cockpit and to look around by turning his or her head.
 This was both intuitive and fun and truly immersed the user in the virtual
 world unlike any conventional PC game today.
 The implementation problem was threefold.
 First we needed to obtain the head rotation, then apply the rotation to
 our camera and finally render the virtual cockpit.
 
\end_layout

\begin_layout Paragraph
Reading head rotation by VRPN
\end_layout

\begin_layout Standard
VRPN was configured according to the lab wikipage 
\begin_inset CommandInset citation
LatexCommand cite
key "idiwiki"

\end_inset

 for settings such as sensor coordinate system and device names.
 To obtain the head rotation we used a .NET wrapper for the VRPN client (VrpnNet-
1.1.1) that greatly simplified the usage in the C# programming language.
 With the correct setup reading sensory data was a trivial task.
\end_layout

\begin_layout Paragraph
Transforming Rotation to World Coordinates
\end_layout

\begin_layout Standard
The second issue was that the sensor coordinate system did not match up
 with XNA.
 The IS-900 system in the laboratory is set up with a right-handed system
 so that X points north, Y points east (towards the windows) and Z points
 down.
 From a sensor point of view north, east and down is +X, +Y and +Z respectively.
\end_layout

\begin_layout Standard
XNA is also right-handed, but here we defined north, east and down as -Z,
 +X and -Y.
 Following the "A simpler approach for orientation" on the Flock of Birds
 ERT wikipage 
\begin_inset CommandInset citation
LatexCommand cite
key "idiwiki"

\end_inset

 we have the following equation to transform the measured HMD orientation
 into XNA world frame.
\begin_inset Formula \begin{equation}
Rot_{XNA}=A_{xref}\times Rot_{sensor}\times A_{xref}^{T}\end{equation}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $A_{xref}^{T}$
\end_inset

 is the matrix found by comparing the sensor's reference frame to the XNA
 frame.
 It can be seen that the sensor +X axis (north) maps to the XNA -Z axis,
 sensor +Y (east) maps to XNA +X and sensor +Z (down) maps to XNA -Y.
 From this we define the following matrix:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula \[
A_{xref}^{T}=\left[\begin{array}{ccc}
0 & 0 & -1\\
1 & 0 & 0\\
0 & -1 & 0\end{array}\right]\begin{array}{c}
(north)\\
(east)\\
(down)\end{array}\]

\end_inset

Here 
\begin_inset Formula $A_{xref}$
\end_inset

 is simply the matrix transpose of 
\begin_inset Formula $A_{xref}^{T}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Rendering a Virtual Cockpit
\end_layout

\begin_layout Standard
To complete the illusion of sitting inside the helicopter we needed a 3D
 cockpit.
 This was achieved by rendering a textured static mesh aligned with the
 helicopter and then positioning the camera at a fixed position relative
 to the mesh at the virtual pilot's head.
 The result is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Virtual-cockpit"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Screenshots/cockpit_overlay.jpg
	lyxscale 50
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Virtual cockpit
\begin_inset CommandInset label
LatexCommand label
name "fig:Virtual-cockpit"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Other Cameras
\end_layout

\begin_layout Standard
Although the cockpit camera was the most comprehensive we also implemented
 three simpler camera types that were useful for both manual and autonomous
 flights.
\end_layout

\begin_layout Paragraph
Free Camera
\end_layout

\begin_layout Standard
One multi-purpose camera that was implemented is the free camera.
 The mouse is used to look around, while the keyboard moves the camera in
 the direction one is looking.
 This camera allows the user to move and look around freely as if flying
 a fictional spaceship.
 Holding down the SHIFT key increases the speed at which the camera is moving
 to cross large distances more quickly.
\end_layout

\begin_layout Paragraph
Fixed Camera
\end_layout

\begin_layout Standard
When testing the autopilot behavior it was often useful to observe the flight
 pattern from a fixed point of view.
 The fixed camera has a fixed position and will always look at a particular
 scene object, such as the helicopter.
 This camera was often used to overview precision navigation scenarios to
 get a better sense of scale and motion.
\end_layout

\begin_layout Paragraph
Chase Camera
\end_layout

\begin_layout Standard
A chase camera was convenient for observing flights over large distances.
 The code was largely reused from an XNA sample at 
\begin_inset CommandInset citation
LatexCommand cite
key "chasecamsample"

\end_inset

 and incorporates a spring to smoothly follow the moving object.
 The spring helps visualize changes in altitude or horizontal motion, since
 the camera will lag behind for a short while before catching up with the
 helicopter.
\end_layout

\begin_layout Section
Simulation of Physics
\begin_inset CommandInset label
LatexCommand label
name "sec:Simulation-of-Physics"

\end_inset


\end_layout

\begin_layout Standard
To challenge the autopilot with semi-realistic navigation scenarios we needed
 a physics simulation.
 This section covers how we implemented the flight behavior and collision
 handling to allow the helicopter to land on the ground.
\end_layout

\begin_layout Subsection
Flight Dynamics Model
\end_layout

\begin_layout Standard
Following the recommendation from our previous work 
\begin_inset CommandInset citation
LatexCommand cite
key "a2ds_project"

\end_inset

 we decided to go with the simplified flight dynamics model (FDM) #4, as
 described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Previous-Work"

\end_inset

.
 This model uses parametric equations for drag and lift with empirically
 chosen coefficients to get a reasonable maximum velocity and control response.
\end_layout

\begin_layout Paragraph
Angular Motion
\end_layout

\begin_layout Standard
One major simplification was to let change in orientation be a direct function
 of joystick output.
 A more realistic simulation would model angular motion by torque from a
 number of sources, such as airflows towards the fuselage, main rotor inertia
 and angular velocity, cyclic controls and the varying lifting force of
 each individual rotor blade over a revolution.
 
\end_layout

\begin_layout Standard
However, from our own experience in flying model helicopters our method
 was a good approximation.
 There a number of reasons for this.
 First, their small scale creates very little moment of inertia when rotated
 so the motion is quickly damped.
 Second, the main rotor will stabilize the orientation in the same manner
 as a spinning wheel will resist reaction to outside forces.
 Third, the tail rotor is designed to counter any unwanted change in heading
 angle, such as by winds or by the torque of the main rotor.
 Added to our own experience in flying model helicopters we assumed that
 the angular momentum was insignificant enough to be ignored in our simplified
 physics simulation.
 
\end_layout

\begin_layout Paragraph
Linear Motion
\end_layout

\begin_layout Standard
Now that angular motion is a function of joystick output we are left with
 forces of linear motion.
 Although the helicopter is an advanced mechanical structure that operate
 by complex aerodynamic phenomena we can simplify the behavior using a model
 of lift and drag forces.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Forces-linear-motion"

\end_inset

 illustrates the forces at work in our flight dynamics model.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "a2ds_project"

\end_inset

 the equations of lift and drag were described as:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
F_{L}=\frac{1}{2}\rho u^{2}AC_{L}\label{eq:lift}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
F_{D}=\frac{1}{2}\rho u^{2}AC_{D}\label{eq:drag}\end{equation}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\rho$
\end_inset

 mass density of the fluid
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $u$
\end_inset

 relative airflow velocity 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
A reference area (typically the square of the mean chord length for a wing)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
C
\begin_inset Formula $_{\text{D}}$
\end_inset

 drag coefficient
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
C
\begin_inset Formula $_{L}$
\end_inset

 lift coefficient
\end_layout

\begin_layout Subparagraph
Drag Force
\end_layout

\begin_layout Standard
Using these equations we had to determine the coefficients and constants.
 Mass density of air is defined in 
\begin_inset CommandInset citation
LatexCommand cite
key "atkinson81"

\end_inset

 as 
\begin_inset Formula $\rho=1.204$
\end_inset

 at sea level and 20 
\begin_inset Formula $\degree C$
\end_inset

.
 The reference area A was chosen as a constant rectangle of 
\begin_inset Formula $0.1\times0.2$
\end_inset

 m, which approximates the cross-section of the model helicopter in forward
 flight.
 
\end_layout

\begin_layout Standard
We know that the body shape affects the drag and that the drag coefficient
 should reflect this.
 
\begin_inset CommandInset citation
LatexCommand cite
key "drag_coeff_games"

\end_inset

 proposes that a cube has 
\begin_inset Formula $C_{D}\approx1.05$
\end_inset

 while the 
\begin_inset Formula $C_{D}$
\end_inset

 of a streamlined body approaches zero.
 We chose 
\begin_inset Formula $C_{D}=1$
\end_inset

 since it produced a maximum velocity of around 80 km/h; a realistic speed
 for model helicopters and in line with the FDM #4 definition.
 
\end_layout

\begin_layout Standard
Relative airflow velocity 
\begin_inset Formula $u$
\end_inset

 is simply the length of a combination of the helicopter velocity vector
 and the wind vector.
 An improved model would take the air flow angle towards the fuselage into
 account and determine an appropriate reference area and drag coefficient.
\end_layout

\begin_layout Subparagraph
Lifting Force
\end_layout

\begin_layout Standard
Based on empirical experiments we found that we wanted the maximum lift
 force to be approximately 70% greater than the force of gravity.
 Again we ignore the inertia of the model helicopter main rotor due to its
 small scale and define relative airflow velocity 
\begin_inset Formula $u$
\end_inset

 of the main rotor blades as a function of joystick throttle 
\begin_inset Formula $h$
\end_inset

.
 We then reduce equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lift"

\end_inset

 to 
\begin_inset Formula $F_{L}=1.7Gh$
\end_inset

.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $h$
\end_inset

 joystick throttle 
\begin_inset Formula $\in\left[0,1\right]$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
G force of gravity
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Physics/LinearForces.png

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Forces at work in linear motion of helicopter according to FDM #4.
\begin_inset CommandInset label
LatexCommand label
name "fig:Forces-linear-motion"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Collision Handling
\end_layout

\begin_layout Standard
In order to prevent the helicopter from flying through the terrain and to
 distinguish between landing and crashing we used the Jitter physics engine.
 Integrating Jitter with our heightmap terrain and helicopter polygonmesh
 introduced a few problems.
 
\end_layout

\begin_layout Standard
First, Jitter did not support heightmaps so we had to construct an indexed
 vertexbuffer of polygons from the heightmap.
 Second we already had a physics component that dealt with the flight dynamics
 so we had to re-route parts of our physics code to Jitter.
 The Jitter integration was solved by first calculating all the linear forces
 and angular velocities in our flight dynamics model, then passing those
 to Jitter for each timestep.
 This way we could add collision handling without any constraints on the
 flight dynamics.
 Third, we just broke the 
\emph on
True Observer Condition
\emph default
 in our state estimator as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Condition-Broken-Collision"

\end_inset

.
 This could only be overcome by disabling collision handling when verifying
 the correctness of the state estimation implementation.
\end_layout

\begin_layout Standard
With those problems solved the collision handling was simply a matter of
 defining a proper bounding volume that represented the mass and volume
 of the helicopter.
 After some difficulties trying to use more accurate compound objects for
 the skids, fuselage and rotors we ended up using a simple rectangular prism
 that matched the dimensions of the helicopter.
 This way to land the helicopter without tipping over was sufficiently difficult.
\end_layout

\begin_layout Section
Simulation of Sensors
\begin_inset CommandInset label
LatexCommand label
name "sec:Simulation-of-Sensors"

\end_inset


\end_layout

\begin_layout Standard
Sensors are an important part of autopilots as they are the only means of
 observing the environment.
 To simulate the behavior of an autopilot as realistically as possible the
 sensors need to be simulated in a realistic manner as well.
 This section covers the sensors in our implementation and how they match
 up with the specifications of commercially available sensors.
 The choice of sensors was based on quality, price and availability for
 future applications.
 All sensor datasheets are included in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-SensorDatasheets"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Sampling Rate
\begin_inset CommandInset label
LatexCommand label
name "sub:Sampling-Rate"

\end_inset


\end_layout

\begin_layout Standard
There are several issues with simulating sensors at different sampling rates
 as proposed by requirement R5 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Requirements"

\end_inset

.
 Our real-time simulation has a game loop that runs at approximately 60
 Hz.
 Each iteration we simulate physics, update the world state and render.
 Having a different sampling rate requires the game loop to run a lot faster
 since the world state must update before taking new sensor measurements.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Different-sampling-rates"

\end_inset

 shows how having two different sampling rates can require the world state
 to update twice as often as the ordinary real-time game loop, even though
 each individual sensor has a lower sampling rate than the original game
 loop.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Sensors/DifferentSamplingRates.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Different sampling rates increases the game loop frequency.
\begin_inset CommandInset label
LatexCommand label
name "fig:Different-sampling-rates"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before adding sensors the render pipeline was typically the bottleneck of
 the game loop, but with different sampling rates the physics simulation
 now has to run multiple times for each render pass and the frame rate easily
 becomes CPU bound.
 We also noted that the problem is not readily parallelizable, since each
 timestep requires the results from the previous timestep.
 The problem escalates when modelling high-rate sensors such as accelerometers
 and gyroscopes that can run at more than 1000 Hz in UAV applications.
 
\end_layout

\begin_layout Standard
To achieve real-time simulation we decided to simplify and sample each sensor
 only once per game loop iteration.
 The advantage was that we could isolate sampling rate when verifying the
 correctness of the state estimator, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Estimation-validity"

\end_inset

, since the state estimator was now synchronized with the simulator.
 Different sampling rates and undersampling was achieved by dropping samples,
 but high-rate sensors were not feasible in real-time so we consider requirement
 R5 to be only partially met.
\end_layout

\begin_layout Subsection
GPS
\begin_inset CommandInset label
LatexCommand label
name "sub:GPS"

\end_inset


\end_layout

\begin_layout Standard
A Global Positioning System (GPS) is a natural part of any navigation system.
 The main advantage is that we get an absolute measurement of the position
 on the planet so any errors in the measurements will not accumulate over
 time.
 The key issues with GPS systems are low sampling rates and that measurements
 are often off by several meters.
 This means that GPS alone will not suffice for autonomous navigation of
 a flying vehicle.
 In our implementation we simulate the FV-M8 GPS from SANAV.
\end_layout

\begin_layout Paragraph
Key Specifications of FV-M8 
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.2
\labelwidthstring 00.00.0000
\noindent
Rate: 
\begin_inset Formula $1\sim5\, Hz$
\end_inset


\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.2
\labelwidthstring 00.00.0000
\noindent
Horizontal
\begin_inset space ~
\end_inset

position
\begin_inset space ~
\end_inset

accuracy: 3.3 m CEP (approx.
 
\begin_inset Formula $\mathcal{N}(0,\,4.9\, m)$
\end_inset

 radius)
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.2
\labelwidthstring 00.00.0000
\noindent
Vertical
\begin_inset space ~
\end_inset

position
\begin_inset space ~
\end_inset

accuracy: N/A (assumed equal to horizontal)
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.2
\labelwidthstring 00.00.0000
\noindent
Velocity
\begin_inset space ~
\end_inset

accuracy: 0.1 Knot RMS (approx.
 
\begin_inset Formula $\mathcal{N}(0,\,0.05\, m/s)$
\end_inset

 radius)
\end_layout

\begin_layout Standard
Typically GPS sensors only deliver position and velocity measurements once
 every second and that is the sampling rate we used.
 The accuracy was specified for aidless tracking and can be further increased
 by DGPS solutions.
 The vertical positional accuracy was not described in the specifications,
 so we assume it is equal to the horizontal accuracy here.
 The tight velocity accuracy is also useful to correct the velocity estimate
 of the IMU, but we suspect that the specifications are not as accurate
 in practice.
\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
A GPS sensor is trivial to implement.
 The true world position is already known from simulation so we only need
 to add navigation frame noise to the measurements.
 An accuracy of 3.3 m CEP
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "CEP"
description "Circular Error Probable"

\end_inset

 (Circular Error Probable) means that 50% of all measurements fall within
 this radius.
 We assume here that the noise follows a Gaussian distribution with zero
 mean and from tables in 
\begin_inset CommandInset citation
LatexCommand cite
after "pp. 146-154"
key "farrel_gpsins"

\end_inset

 we convert CEP to a standard deviation of 
\begin_inset Formula $\sigma_{pos}\approx4.9\, m$
\end_inset

.
 Velocity accuracy is already expressed in standard deviation so we simply
 convert to metric and find 
\begin_inset Formula $\sigma_{vel}\approx0.05\, m/s$
\end_inset

.
 
\end_layout

\begin_layout Standard
To implement the random position error we generated a random normalized
 3D vector and multiplied it with a distance 
\begin_inset Formula $d\sim\mathcal{N}(0,\,\sigma_{pos})$
\end_inset

.
 The GPS position is then obtained by adding the random position error vector
 to the true position vector.
 The GPS is then modelled to let 68% of the position measurements be within
 4.9 m of the truth.
 The random velocity error vector was calculated in a similar manner.
\end_layout

\begin_layout Subsection
IMU
\begin_inset CommandInset label
LatexCommand label
name "sub:IMU"

\end_inset


\end_layout

\begin_layout Standard
Inertial Measurement Unit (IMU) is a widely used concept in inertial navigation
 systems (INS).
 The typical configuration consists of accelerometers and gyroscopes arranged
 to measure linear acceleration and angular velocity of a body.
 Given a known starting state we can estimate the position and orientation
 by dead-reckoning, however in practice this estimate will quickly drift
 away from truth due to noise, inaccuracy, precision and discretization.
 This section covers the implementation of the two sensors required for
 an IMU.
\end_layout

\begin_layout Subsubsection
Accelerometer
\begin_inset CommandInset label
LatexCommand label
name "sub:Accelerometer"

\end_inset


\end_layout

\begin_layout Standard
An accelerometer measures linear acceleration along one or more axes and
 we use this to calculate the velocity and position of the helicopter.
 Accelerometers can typically run at very high rates and accurately captures
 changes in linear motion for short intervals of time.
 In our implementation we simulate the ADXL330 accelerometer from Analog
 Devices.
\end_layout

\begin_layout Subparagraph
Key Specifications of ADXL330
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Rate: Max.
 1600 Hz
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\noindent
Range: 
\begin_inset Formula $\pm3\, g$
\end_inset


\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Noise
\begin_inset space ~
\end_inset

density
\begin_inset space ~
\end_inset

forward/right: 280 
\begin_inset Formula $\mu g/\sqrt{Hz}RMS$
\end_inset


\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Noise
\begin_inset space ~
\end_inset

density
\begin_inset space ~
\end_inset

up: 350 
\begin_inset Formula $\mu g/\sqrt{Hz}RMS$
\end_inset


\end_layout

\begin_layout Standard
The noise is specified to resemble Gaussian behavior at all frequencies.
 In order to translate density to an actual noise level we must first determine
 what bandwidth we require the sensor to run at.
 The bandwidth decides what frequencies to encompass and according to 
\begin_inset CommandInset citation
LatexCommand cite
key "DIY_UAV_platform"

\end_inset

 a good choice for UAV navigation is a bandwidth of 0-400 Hz, for a number
 of mechanical and electrical reasons.
 This gives noise RMS levels of: 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\sigma_{right}=\mathbf{\sigma}_{fwd} & = & 280\times10^{-6}\sqrt{400}=7.1E-3\, g\\
\sigma_{up} & = & 350\times10^{-6}\sqrt{400}=8.9E-3g\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
The sensor measures acceleration in the body reference frame, while both
 the physics simulation and the state estimator operates in the navigation
 frame.
 To implement an accelerometer we need to transform the simulated world
 acceleration vector to body frame.
 Then the state estimator needs to transform the accelerometer vector back
 to navigation frame, which should ideally equal the simulated vector.
 Unfortunately there is a precision loss in converting between reference
 frames so that the state estimator would be off even if no noise or inaccuracy
 were added to the sensors.
 
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Impl"

\end_inset

 we discuss how we needed to verify the correctness of the state estimator
 by zero deviation when no noise was added to the sensors.
 For this case we cheated and passed the world acceleration vector directly
 to the state estimator.
 This way only the noise vector would need to be transformed and so the
 loss in precision would only be a negligible addition to the noise.
 Obviously this is not possible using real sensors and is only useful in
 a simulation scenario to verify the validity of the state estimator.
 Details of the transformation precision loss is found in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Precision-Frames"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Gyroscope
\end_layout

\begin_layout Standard
A gyroscope measures the angular velocity of one or more axes and we use
 it to estimate the orientation of the helicopter.
 Gyroscopes run at high rates and accurately captures changes to the orientation
 over short periods of time, but will drift away from truth over time.
 In our implementation we simulate the LYPR540AH 3-axial gyroscope from
 ST.
\end_layout

\begin_layout Subparagraph
Key Specifications of LYPR540AH
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Rate: Max.
 140 Hz
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\noindent
Range: 
\begin_inset Formula $\pm400\,\degree/s$
\end_inset


\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Noise
\begin_inset space ~
\end_inset

density: 0.02 
\begin_inset Formula $\degree/\sqrt{Hz}RMS$
\end_inset


\end_layout

\begin_layout Standard
The range of this sensor should suffice for our autopilot.
 Helicopters are an unstable platform so we want to avoid sudden changes
 to the orientation to ensure we do not lose control of the vehicle.
 Once more noise is defined as a density function of bandwidth and for this
 sensor we use a bandwidth of 0-140 Hz.
 This gives a noise RMS level for each axis of:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \begin{eqnarray*}
\sigma_{axis} & = & 0.02\sqrt{140}\approx0.24\,\degree/s\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
The gyroscope was implemented by calculating the angular velocity each timestep.
 First we used the straight forward solution of calculating the angular
 displacement as 
\begin_inset Formula $d_{i}=\triangle\theta_{i}$
\end_inset

 and angular velocity as 
\begin_inset Formula $\omega_{i}=\frac{d_{i}}{\triangle t}$
\end_inset

 for Euler angles 
\begin_inset Formula $\theta_{1},\theta_{2},\theta_{3}$
\end_inset

.
 Later we discovered that this delayed the state estimator by one iteration
 since the angular velocity would reflect the change from the previous to
 the current point of time instead of the current angular velocity.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Physics"

\end_inset

 we describe how the orientation of the helicopter is simply a function
 of the joystick output in the physics simulation.
 This way we can simply formulate the measured angular velocity as a function
 of joystick output.
\end_layout

\begin_layout Subsection
Range Finder
\begin_inset CommandInset label
LatexCommand label
name "sub:Rangefinder"

\end_inset


\end_layout

\begin_layout Standard
The range finder was added to the setup to enable low flight scenarios such
 as flying along terrain.
 GPS and inertial navigation systems suffer from inaccuracy of up to several
 meters and easily confuses the autopilot logic due to large sudden jumps
 in estimated position.
 The range finder typically uses sonar, LASER or RADAR technologies to measure
 the distance to an object with great accuracy.
 In our implementation we simulate the LV-MaxSonar-EZ0 sonar range finder
 from MaxBotix.
\end_layout

\begin_layout Standard
A typical mounting for the range finder is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Measuring-flat-ground"

\end_inset

.
 Here the sensor points in the down direction of the vehicle and returns
 the range to nearest object within the range and width of its 
\emph on
beam
\emph default
.
 We use this beam primarily to measure the height above the ground and its
 high accuracy surpasses the INS/GPS estimates for this task.
 By telling the autopilot to hold a fixed height above the ground we can
 now navigate just a few metres above the terrain with much less risk of
 crashing.
\end_layout

\begin_layout Paragraph
Key Specifications of LV-MaxSonar-EZ0 
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Rate: 20 Hz
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Range: 0 m - 6.45 m (extended to 10 m)
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Resolution: 2.54 cm
\end_layout

\begin_layout Labeling
\paragraph_spacing other 0.5
\labelwidthstring 00.00.0000
\noindent
Noise: N/A
\end_layout

\begin_layout Standard
One obvious limitation here is the range of just about 6 meters.
 The autopilot can only follow the terrain as long as it can measure the
 distance to the ground, so naturally we are restricted to flying no higher
 than roughly 5 meters above the terrain.
 This leaves little room for error and would never be acceptable for real
 outdoor navigation.
 However, for our simulation it still serves a purpose so we decided to
 slightly extend the range to 10 m to allow for more interesting testing
 scenarios.
 The resolution, noise levels and measurement rates was expected to prove
 sufficient for our application and the final results are found in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Test-Results"

\end_inset

.
 The sensor datasheet does not mention any noise so we simply considered
 the resolution of 2.54 cm as the only uncertainty in our application.
\end_layout

\begin_layout Paragraph
Flat Ground Height
\end_layout

\begin_layout Standard
There is one big issue with using a range finder to measure height above
 the ground.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Measuring-flat-ground"

\end_inset

 shows how we measure what we call 
\emph on
Flat Ground Height
\emph default
 (FGH
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "FGH"
description "Flat Ground Height, a method used by the range finder to estimate height above the ground."

\end_inset

).
 When estimating the height above the ground we assume the ground is flat
 and simply use the vertical component of the measured range to find FGH.
 Helicopter A is pointing its sensor straight down and so FGH equals height
 above the ground at that point.
 Helicopter B, however, is pitching its nose down in order to accelerate
 forwards and consequently the sensor is now pointing at an angle.
 Intuitively we can see that FGH no longer equals height above the ground
 and we get an estimate error depending on the curvature of the terrain
 and the orientation of the helicopter.
 Later in the experiments section we show that it was indeed possible to
 navigate along the terrain using datasheet sensors and the FGH method.
\end_layout

\begin_layout Standard
One a side note, it is possible to mount the sensor to always point straight
 down to overcome the problem of measuring height in the first place.
 This could be arranged by a simple PID-controller and two servos, since
 it has an estimate of the current orientation.
 However, for small remote controlled helicopters this setup may not be
 feasible due to limitations in weight, batteries and space so we chose
 the former method.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Sensors/FlatGroundHeight_measurements.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Measuring flat ground height.
\begin_inset CommandInset label
LatexCommand label
name "fig:Measuring-flat-ground"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Implementation
\end_layout

\begin_layout Standard
Another issue was how to properly implement the sensor.
 We needed to simulate the fact that the sensor is pointing at an angle
 towards the terrain, so we decided to use a form of raycasting for this.
 The terrain was defined as a heightmap and since most raycast implementations
 work with polygons and bounding boxes we implemented our own raycaster
 using the binary search algorithm.
 
\end_layout

\begin_layout Standard
The idea is very simple and the recursive function is started by providing
 the helicopter position, the sensor beam world direction and the max range
 of the beam.
 This range is then cut in two halves and each subrange is then recursively
 checked for intersection with the heightmap.
 The problem is that we don't have sorted heights along the ray so we must
 determine if an intersection exists by other means.
 One simplification is to compare the height above the ground (HAG
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "HAG"
description "Height Above the Ground"

\end_inset

) for the start and end points of that range.
 GetAltitude(point) looks up the positions in the heightmap map by bi-linear
 interpolation and returns the HAG for a world point.
 If both are on the same side of the terrain (above or below) we assume
 that line segment does not intersect with the terrain.
 If not, the line segment does intersect and we recursively search for it.
 The function returns the midpoint of a line segment as the intersection
 point once the length of the line segment is less than the specified resolution
 of 2.54 cm.
 
\end_layout

\begin_layout Standard
The method worked well in our scenario and should be faster than linear
 searching raycasting algorithms.
 However, our method does suffer from corner cases that could break the
 functionality.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Corner-case-of"

\end_inset

 shows how the measured range can become undefined if the terrain curvature
 is hilly and the helicopter is flying low with a significant tilt.
 Here our intersection check fails since both the start and end points are
 above the terrain.
 The tests, however, did not indicate any problems with this case since
 the autopilot is configured to not exceed 
\begin_inset Formula $10\degree$
\end_inset

 of pitch or roll and since our terrains were not as extreme as depicted
 in the figure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Sensors/BinarySearchRaycast.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Corner case of the binary search raycasting algorithm.
\begin_inset CommandInset label
LatexCommand label
name "fig:Corner-case-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

float FindIntersectionDistance
\end_layout

\begin_layout Plain Layout

(float minRange, float maxRange, float maxError, Vector3 position, Vector3
 worldDirection) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  if (distance(minRange, maxRange) <= maxError) 
\end_layout

\begin_layout Plain Layout

    return (minRange + maxRange) / 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  float halfRange = minRange + (maxRange - minRange) / 2; 
\end_layout

\begin_layout Plain Layout

  Vector3 rayStartPosition = position + minRange * worldDirection; 
\end_layout

\begin_layout Plain Layout

  Vector3 rayHalfPosition = position + halfRange * worldDirection; 
\end_layout

\begin_layout Plain Layout

  Vector3 rayEndPosition = position + maxRange * worldDirection; 
\end_layout

\begin_layout Plain Layout

  float startGroundAltitude = GetAltitude(rayStartPosition); 
\end_layout

\begin_layout Plain Layout

  float halfPointGroundAltitude = GetAltitude(rayHalfPosition); 
\end_layout

\begin_layout Plain Layout

  float endGroundAltitude = GetAltitude(rayEndPosition);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Height Above Ground 
\end_layout

\begin_layout Plain Layout

  float startHAG = rayStartPosition.Y - startGroundAltitude; 
\end_layout

\begin_layout Plain Layout

  float halfPointHAG = rayHalfPosition.Y - halfPointGroundAltitude; 
\end_layout

\begin_layout Plain Layout

  float endHAG = rayEndPosition.Y - endGroundAltitude;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if (startHAG > 0 && halfPointHAG <= 0)
\end_layout

\begin_layout Plain Layout

  return BinarySearchTerrainRayIntersection(minRange, halfRange, maxError,
 position,  worldDirection);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if (halfPointHAG > 0 && endHAG <= 0)
\end_layout

\begin_layout Plain Layout

  return BinarySearchTerrainRayIntersection(halfRange, maxRange, maxError,
 position, worldDirection);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 return float.NaN; 
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-code for raycasting implemented by binary search.
\begin_inset CommandInset label
LatexCommand label
name "alg:Raycasting-implemented-by"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
State Estimation
\begin_inset CommandInset label
LatexCommand label
name "sec:State-Estimation-Impl"

\end_inset


\end_layout

\begin_layout Standard
The state estimator provides the only input to our autopilot about where
 it currently is and where it is headed.
 This section explains how we implemented a Kalman filter to estimate position,
 velocity and orientation of the helicopter from noisy and incomplete sensor
 measurements and what issues we encountered.
\end_layout

\begin_layout Subsection
GPS/INS Kalman Filter
\end_layout

\begin_layout Standard
GPS/INS Kalman filter is a widely used method for autonomous outdoor navigation.
 An inertial navigation system (INS) provides position and orientation estimates
 by dead reckoning from the IMU measurements, while the GPS provides absolute
 position and velocity estimates from satellite signal processing.
 
\end_layout

\begin_layout Standard
We mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Flight-Sensors"

\end_inset

 how absolute and relative measurements differ and that is why the GPS and
 INS complement each other.
 The INS a high sampling rate and excel at representing motion over short
 periods of time and capturing sudden changes in motion.
 However, due to the integration of angular velocity and the double integration
 of linear acceleration these estimates quickly diverge from the truth.
 This is where the GPS becomes useful.
 The GPS has a very low sampling rate (typically 1 Hz) and an inaccuracy
 of up to several meters, however the error is near-Gaussian and centered
 at the truth so we can use it to prevent the INS estimate from diverging
 too much.
 
\end_layout

\begin_layout Paragraph
Omitting the Orientation Estimate
\begin_inset CommandInset label
LatexCommand label
name "sub:Omitting-Orientation-Estimate"

\end_inset


\end_layout

\begin_layout Standard
Ordinarily the INS/GPS filter should estimate position, velocity and orientation
 from noisy and incomplete sensor measurements, but expressing equations
 for orientation in the process model and the observation model and constructing
 the covariance matrices 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 and 
\begin_inset Formula $\mathbf{R}$
\end_inset

 was not easily achieved.
 Although we had several sources (
\begin_inset CommandInset citation
LatexCommand cite
key "ronnback:msc,kf_quaternion,ukf_imu_gps_compass"

\end_inset

) that proposed solutions, we did not find enough time to get the implementation
 right, so in this section we have left out the angular velocity measurements
 from the control input vector 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and the orientation quaternion 
\begin_inset Formula $\mathbf{q}$
\end_inset

 from the state model for simplicity.
 Some descriptions and figures will still include these two to illustrate
 the intended function of the filter.
 In our flight experiments we compensated for the lack of uncertainty by
 adding an error bias to the true orientation.
\end_layout

\begin_layout Paragraph
Overview
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:KF-Trust-Circles"

\end_inset

 illustrates how the Kalman filter relies on the INS in-between GPS updates
 and the circles denote how the INS estimate uncertainty increases over
 time.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Kalman Filter/GPSINS_trust_circles.png
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The accuracy of the INS estimate degrades over time and its error is corrected
 by the more reliable GPS measurement.
\begin_inset CommandInset label
LatexCommand label
name "fig:KF-Trust-Circles"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The two key Kalman filter equations we need to consider here is the process
 model 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-process-model-impl"

\end_inset

 and the observation model 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-observation-model-impl"

\end_inset

.
 Refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Theory"

\end_inset

 for the background theory.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray}
\mathbf{x}_{k} & = & \mathbf{A}_{k}\mathbf{x}_{k-1}+\mathbf{B}_{k}\mathbf{u}_{k}+\mathbf{w}_{k}\label{eq:KF-process-model-impl}\\
\mathbf{z}_{k} & = & \mathbf{H}_{k}\mathbf{x}_{k}+\mathbf{v}_{k}\label{eq:KF-observation-model-impl}\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overview-of-the-KF"

\end_inset

 illustrates how we have configured the Kalman filter to estimate position,
 velocity and orientation of the helicopter.
 Each timestep we fuse sensor information from the GPS and the IMU.
 The filter then integrates the linear acceleration and angular velocities
 to produce an INS state estimate, which is then compared to the GPS position
 and velocity observations by their magnitudes of uncertainty.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Kalman Filter/GPSINS_Filter_Overview.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Overview of the GPS/INS Kalman filter configuration.
\begin_inset CommandInset label
LatexCommand label
name "fig:Overview-of-the-KF"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Symbols
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{p}$
\end_inset

 position in navigation frame
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\dot{\mathbf{p}}$
\end_inset

 velocity in navigation frame
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $\ddot{\mathbf{p}}$
\end_inset

 linear acceleration in navigation frame
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $t$
\end_inset

 timestep duration in fraction of seconds
\end_layout

\begin_layout Paragraph
State Model
\end_layout

\begin_layout Standard
Since we have omitted the orientation filtering we are left with estimating
 the position and velocity of the helicopter.
 In our implementation we used the north-east-down (NED) navigation frame
 and chose origo at 
\begin_inset Formula $\mathbf{p}_{ned}=\left(\begin{array}{ccc}
0, & 0, & 0\end{array}\right).$
\end_inset

 We define our state as:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \begin{eqnarray*}
\mathbf{x} & = & \left[\begin{array}{cccccc}
p_{n} & p_{e} & p_{d} & \dot{p}_{n} & \dot{p}_{e} & \dot{p}_{d}\end{array}\right]^{T}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
State Transition Model
\end_layout

\begin_layout Standard
Part of the process model is defined by the state transition model 
\begin_inset Formula $\mathbf{A}$
\end_inset

, which describes how we believe the true state 
\begin_inset Formula $\mathbf{x}$
\end_inset

 will propagate by time without any control input.
 From the equation of linear motion 
\begin_inset Formula $\mathbf{p}=\mathbf{p}_{0}+\mathbf{v}t$
\end_inset

 we formulate our transition model 
\begin_inset Formula $\mathbf{A}$
\end_inset

 so that
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \begin{eqnarray*}
\mathbf{Ax} & = & \left[\begin{array}{cccccc}
1 & 0 & 0 & t & 0 & 0\\
0 & 1 & 0 & 0 & t & 0\\
0 & 0 & 1 & 0 & 0 & t\\
0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{c}
p_{n}\\
p_{e}\\
p_{d}\\
\dot{p}_{n}\\
\dot{p}_{e}\\
\dot{p}_{d}\end{array}\right]\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
describes the change in position due to velocity over time.
\end_layout

\begin_layout Paragraph
Control Input Model
\end_layout

\begin_layout Standard
The control input 
\begin_inset Formula $\mathbf{u}$
\end_inset

 is typically a vector of variables controlled by the autopilot.
 How the control input is expected to change the state is defined by the
 control input model 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
 According to 
\begin_inset CommandInset citation
LatexCommand cite
key "ronnback:msc"

\end_inset

 we can use measured linear acceleration and angular velocity as control
 input to fuse INS and GPS measurements.
 Note that the angular velocity input is omitted here for clarity, as already
 explained, so we define our control input vector:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{u} & = & \left[\begin{array}{ccc}
\ddot{p}_{n} & \ddot{p}_{e} & \ddot{p}_{d}\end{array}\right]^{T}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
From the equations of linear motion 
\begin_inset Formula $\mathbf{p}=\mathbf{p}_{0}+\frac{1}{2}\mathbf{a}t^{2}$
\end_inset

 and 
\begin_inset Formula $\mathbf{v}=\mathbf{v}_{0}+\mathbf{a}t$
\end_inset

 we define our control input model 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\mathbf{B}$
\end_inset

 so that 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{Bu} & = & \left[\begin{array}{ccc}
\frac{1}{2}t^{2} & 0 & 0\\
0 & \frac{1}{2}t^{2} & 0\\
0 & 0 & \frac{1}{2}t^{2}\\
t & 0 & 0\\
0 & t & 0\\
0 & 0 & t\end{array}\right]\left[\begin{array}{c}
\ddot{p}_{n}\\
\ddot{p}_{e}\\
\ddot{p}_{d}\end{array}\right]\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
describes the change in position and velocity due to linear acceleration.
 
\end_layout

\begin_layout Paragraph
Process Model
\end_layout

\begin_layout Standard
The process model is given by equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-process-model-impl"

\end_inset

 and denotes how a combination of the state transition model 
\begin_inset Formula $\mathbf{A}$
\end_inset

 and the control input model 
\begin_inset Formula $\mathbf{B}$
\end_inset

 follows the modelled process with some process noise 
\begin_inset Formula $\mathbf{w}$
\end_inset

.
 The main source of noise in our process model is the IMU sensor measurements
 in the control input 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and the process noise 
\begin_inset Formula $\mathbf{w}\sim\mathcal{N}(0,\mathbf{Q})$
\end_inset

 is assumed to be drawn from a zero mean multivariate normal distribution
 with covariance 
\begin_inset Formula $\mathbf{Q}$
\end_inset

.
 The predicted estimate covariance 
\begin_inset Formula $\mathbf{P}_{k}^{-}$
\end_inset

 can then model the linear increase in uncertainty of the INS estimate over
 time by equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-predicted-estimate-covariance"

\end_inset

.
 This is also illustrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:KF-Trust-Circles"

\end_inset

 by the dotted circles.
\end_layout

\begin_layout Standard
From the sensor specifications in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IMU"

\end_inset

 we have the standard deviations
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{S}_{Q} & = & \left[\begin{array}{ccc}
\sigma_{accel,right} & \sigma_{accel,up} & \sigma_{accel,right}\end{array}\right]^{T}\\
 & = & \left[\begin{array}{ccc}
7.1E-3\, g & 8.9E-3\, g & 7.1E-3\, g\end{array}\right]^{T}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
for the control input 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and define the process model covariance matrix:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{Q}=\mathbf{B}\mathbf{B}^{T}\mathbf{S}_{Q}^{2} & = & \left[\begin{array}{ccc}
\frac{1}{4}t^{4} & 0 & 0\\
0 & \frac{1}{4}t^{4} & 0\\
0 & 0 & \frac{1}{4}t^{4}\\
\frac{1}{2}t^{3} & 0 & 0\\
0 & \frac{1}{2}t^{3} & 0\\
0 & 0 & \frac{1}{2}t^{3}\end{array}\right]\left[\begin{array}{c}
\left(7.1E-3\right)^{2}\\
\left(8.9E-3\right)^{2}\\
\left(7.1E-3\right)^{2}\end{array}\right]\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Observation Model
\end_layout

\begin_layout Standard
The GPS sensor measures position and velocity with known noise distributions.
 We define our observation vector:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{z} & = & \left[\begin{array}{cccccc}
p_{n} & p_{e} & p_{d} & \dot{p}_{n} & \dot{p}_{e} & \dot{p}_{d}\end{array}\right]^{T}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
From equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-observation"

\end_inset

 we define our observation model 
\begin_inset Formula $\mathbf{H}$
\end_inset

 so that 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{z}=\mathbf{Hx}+\mathbf{v} & = & \left[\begin{array}{cccccc}
1 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{c}
p_{n}\\
p_{e}\\
p_{d}\\
\dot{p}_{n}\\
\dot{p}_{e}\\
\dot{p}_{d}\end{array}\right]+\mathbf{v}\\
\mathbf{v} & \sim & \mathcal{N}(0,\mathbf{R})\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
describes the observed position and velocity with some observation noise
 
\begin_inset Formula $\mathbf{v}$
\end_inset

.
 The noise is assumed to be drawn from a zero mean multivariate normal distribut
ion with covariance 
\begin_inset Formula $\mathbf{R}$
\end_inset

.
 Filling in the values from the sensor specifications in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GPS"

\end_inset

 we get the standard deviations 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{S}_{R} & = & \left[\begin{array}{cccccc}
\sigma_{GPS,pos,n} & \sigma_{GPS,pos,e} & \sigma_{GPS,pos,d} & \sigma_{GPS,vel,n} & \sigma_{GPS,vel,e} & \sigma_{GPS,vel,d}\end{array}\right]^{T}\\
 & = & \left[\begin{array}{cccccc}
2.83\, m & 2.83\, m & 2.83\, m & 0.05\, m/s & 0.05\, m/s & 0.05\, m/s\end{array}\right]^{T}\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
for our observation 
\begin_inset Formula $\mathbf{z}$
\end_inset

 and define the GPS noise covariance matrix:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
\mathbf{R}=\mathbf{S}_{R}\mathbf{S}_{R}^{T} & = & \left[\begin{array}{cccccc}
7.98 & 0 & 0 & 0 & 0 & 0\\
0 & 7.98 & 0 & 0 & 0 & 0\\
0 & 0 & 7.98 & 0 & 0 & 0\\
0 & 0 & 0 & 2.5E-3 & 0 & 0\\
0 & 0 & 0 & 0 & 2.5E-3 & 0\\
0 & 0 & 0 & 0 & 0 & 2.5E-3\end{array}\right]\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Applying the Kalman Filter in the Simulation
\end_layout

\begin_layout Standard
Now that we have defined the process model, the observation model and their
 covariances from sensor datasheets solving the Kalman filter is simply
 a matter of applying the equations described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kalman-Filter-Theory"

\end_inset

.
 We implemented the Kalman filter in the class GPSINSFilter, which computes
 state estimates each game loop iteration from GPS and INS measurements.
\end_layout

\begin_layout Standard
First the filter must be initialized to an initial guess of the starting
 condition.
 In our helicopter test scenarios we assumed that the starting condition
 was well known and set 
\begin_inset Formula $\hat{\mathbf{x}}_{0}$
\end_inset

 to reflect the true position, velocity and orientation of the helicopter.
 When the initial state is well known we can also set the initial estimate
 covariance 
\begin_inset Formula $\mathbf{P}_{0}$
\end_inset

 to a zero matrix, which will let the filter consider this initial estimate
 as certain.
\end_layout

\begin_layout Standard
For each game loop iteration the filter receives noisy IMU measurements
 of linear acceleration and angular velocity.
 As described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kalman-Filter-Theory"

\end_inset

 the filter then 
\emph on
predicts 
\emph default
the new state 
\begin_inset Formula $\hat{\mathbf{x}}_{k}^{-}$
\end_inset

 based on the previous state estimate 
\begin_inset Formula $\hat{\mathbf{x}}_{k-1}$
\end_inset

, the current control input 
\begin_inset Formula $\mathbf{u}_{k}$
\end_inset

 and the known process model outlined by the prediction equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-predicted-estimate-state"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KF-predicted-estimate-covariance"

\end_inset

.
\end_layout

\begin_layout Standard
GPS measurements of position and velocity are received once per second.
 When observations are available then the former prediction is 
\emph on
corrected
\emph default
 by an optimal Kalman gain factor that distributes its trust between the
 process model estimate and the observation model estimate.
 The trust distribution is based on the modelled covariances of the INS
 and GPS estimates and the accumulated uncertainty of the INS estimate versus
 the uncertainty of the GPS measurements.
 The corrected estimates for state 
\begin_inset Formula $\hat{\mathbf{x}}_{k}$
\end_inset

 and covariance 
\begin_inset Formula $\mathbf{P}_{k}$
\end_inset

 are the final estimates for state 
\begin_inset Formula $k$
\end_inset

 and in the next game loop iteration those estimates are used to once more
 predict state 
\begin_inset Formula $k+1$
\end_inset

.
\end_layout

\begin_layout Standard
As we already noted, our implementation of the Kalman filter omits the angular
 velocities in the control input vector 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and simply inserts the simulated orientation into the estimated state vector
 
\begin_inset Formula $\hat{\mathbf{x}}$
\end_inset

.
 Errors in estimated orientation will greatly affect the INS position uncertaint
y over time, so to compensate we periodically added a proper random error
 to the yaw, pitch and roll angles.
 
\end_layout

\begin_layout Paragraph
Fusion of Asynchronous Sensors
\end_layout

\begin_layout Standard
One big issue with sensors is that they often run at very different sampling
 frequencies.
 In our GPS/INS filter the GPS samples once per second, while the IMU is
 configured to sample 60 times per second.
 To model the filter to trust entirely on INS estimates in-between GPS updates
 we set the observation model matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

 to a zero matrix the 59 times per second when no new GPS observation was
 available.
 This caused the optimal Kalman gain matrix 
\begin_inset Formula $\mathbf{K}$
\end_inset

 to zero out the row-column pairs for the observed position and the velocity
 state variables and in effect ignore those observations in the corrected
 estimate 
\begin_inset Formula $\hat{\mathbf{x}}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Range Finder for HAG Measurements
\end_layout

\begin_layout Standard
The range finder in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Rangefinder"

\end_inset

 was added to accurately measure the height above the ground (HAG).
 This was necessary because the INS/GPS was too inaccurate for low level
 flights along the curvature of the terrain.
 Ideally one should filter the HAG, but due to the way our range finder
 measured HAG its noise distribution was no longer Gaussian and that violated
 one of the Kalman filter assumptions in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kalman-Filter-Theory"

\end_inset

.
 Instead we simply replaced the GPS/INS altitude estimate by the range finder
 HAG measurement and let the autopilot maintain a certain height above the
 ground during navigation.
\end_layout

\begin_layout Subsection
Separating Linear and Angular State Updates
\end_layout

\begin_layout Standard
We had to take special care to model the Kalman filter process model exactly
 identical to the simulation physics model to avoid estimate deviations
 due to subtle implementation differences.
 Unfortunately, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Omitting-Orientation-Estimate"

\end_inset

, it proved difficult to model the change in angular state in the Kalman
 filter so we had to make a simplification.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Update-sequence-simulation-estimation"

\end_inset

 shows how the simulation first updates the linear state and then updates
 the angular state.
 This way the two are isolated and much easier to model in the Kalman filter.
 We assumed the effects of this simplification would be negligible since
 the small timesteps would minimize the error and we were not using a very
 realistic physics model to begin with.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Kalman Filter/Update_sequence.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Update sequence of simulation and state estimator.
\begin_inset CommandInset label
LatexCommand label
name "fig:Update-sequence-simulation-estimation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Estimation Validity
\begin_inset CommandInset label
LatexCommand label
name "sub:Estimation-validity"

\end_inset


\end_layout

\begin_layout Standard
One very strict requirement to our implementation was that the simulation
 and the state estimator should produce the exact same results if a certain
 condition was met.
 A virtual sensor is said to be 
\emph on
perfect
\emph default
 when no noise is added to the measurement and a sample is read each timestep.
 If we simulate using only perfect sensors then the simulated linear force
 vector and the angular velocities should be perfectly reconstructed by
 the IMU each timestep.
 We call this the 
\emph on
True Observer Condition
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "True Observer Condition"
description "All sensors are noiseless and sample each timestep."

\end_inset


\emph default
.
\end_layout

\begin_layout Standard
This requirement was crucial to ensure that any deviation between the true
 and the estimated states was due to noisy and incomplete measurements and
 not errors in the implementation.
 Without this requirement the estimation errors would not be useful to evaluate
 the autopilot performance.
 The test results for configuration #1 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Test-Results"

\end_inset

 shows that we were able to satisfy this requirement using perfect virtual
 sensors.
\end_layout

\begin_layout Paragraph
Validity Broken by Precision Issue
\end_layout

\begin_layout Standard
The True Observer Condition required the physics simulation and the state
 estimator to produce identical results.
 Here we discovered a problem that the simulated and the estimated orientation
 deviated after many iterations even when the condition was met.
 The deviation in estimated orientation caused the position estimate to
 deviate by 3 cm after 30 seconds of flight and quickly diverge as the velocity
 error accumulated.
 
\end_layout

\begin_layout Standard
After some research we isolated the error to two pieces of code that calculated
 the new state in the simulator and in the state estimator.
 Given identical inputs these should produce exactly the same results.
 The reason was a subtle syntactical difference illustrated by the pseudo-code
 in algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Pseudo-code-for-floating"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
const float A, B, C, dt; // Any non-zero values
\end_layout

\begin_layout Plain Layout
float result1 = (A*B)*dt;
\end_layout

\begin_layout Plain Layout
float result2 = (A*B); 
\end_layout

\begin_layout Plain Layout
result2 *= dt; 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo-code for floating point precision issue.
\begin_inset CommandInset label
LatexCommand label
name "alg:Pseudo-code-for-floating"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here result1 and result2 was expected to produce equal results, but their
 precision differed due to technical details covered in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Precision-Float-Operations"

\end_inset

.
 The workaround was to ensure that both the simulation and the state estimator
 used the exact same piece of code to calculate the change in orientation.
\end_layout

\begin_layout Paragraph
Validity Broken by Collision Handling
\begin_inset CommandInset label
LatexCommand label
name "sub:Condition-Broken-Collision"

\end_inset


\end_layout

\begin_layout Standard
When we introduced collision handling with Jitter the physics library we
 realized that the validity requirement could no longer be met.
 The physics calculations were now largely done by the library and we could
 no longer guarantee that state estimator would compute the exact same results.
 This was very unfortunate and was not discovered before at the end of the
 project.
 This meant that while using collision handling we could no longer prove
 that any deviation in the state estimation was a result of imperfections
 in the sensor data alone.
 The solution was to disable collision handling by Jitter if we later needed
 to re-verify the validity of the state estimation.
\end_layout

\begin_layout Section
Autopilot
\end_layout

\begin_layout Standard
Now that we have an understanding of how physics simulation, virtual sensors
 and state estimation work we can approach the task of getting the helicopter
 to fly on its own.
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The autopilot control logic is divided in two.
 The autopilot class handles the navigation planning and breaks it down
 into simple navigation commands, which the output controller then transforms
 into joystick outputs as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Autopilot-and-outputcontroller"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/Autopilot_OutputController.png
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The autopilot and output controller components.
\begin_inset CommandInset label
LatexCommand label
name "fig:Autopilot-and-outputcontroller"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The autopilot is very comprehensive so an overview is given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overview-autopilot-pids"

\end_inset

 on how the the output controller, Kalman filter and PID configurations
 are set up according to the velocity controlled cyclic navigation method
 we ended up using, explained later in this section.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/AutopilotAndPIDsOverview.png
	lyxscale 50
	height 18cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Overview of the autopilot and the PID configurations for the velocity controlled
 cyclic navigation method.
 BF
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "BF"
description "Body Frame"

\end_inset

 denotes body frame.
\begin_inset CommandInset label
LatexCommand label
name "fig:Overview-autopilot-pids"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Autopilot Class
\begin_inset CommandInset label
LatexCommand label
name "sec:Autopilot-Logic"

\end_inset


\end_layout

\begin_layout Standard
The autopilot is primarily concerned with how to avoid crashing and how
 to get from A to B.
 When the autopilot is initialized it is given a navigation task, which
 holds a series of waypoints.
 It is the responsibility of the autopilot to keep track of the task progression
 and command the output controller so that all waypoints are visited in
 sequence.
 We implemented three commands; en route, hover and recovery.
 En route tells the output controller to move towards B without crashing,
 while hover attempts to keep the helicopter at a fixed position in the
 air.
 Recovery is issued if the autopilot detects that we are in risk of crashing
 and will override all logic to gain altitude as quickly as possible.
\end_layout

\begin_layout Subsection
State Provider Classes
\end_layout

\begin_layout Standard
The only input to the autopilot is the current state of the helicopter,
 given by any IStateProvider implementation as seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Class-diagram-of"

\end_inset

.
 The helicopter state mainly consists of its position, orientation, their
 derivatives and the navigation state.
 This was an architectural choice that allowed us to swap on-the-fly between
 a perfect state provider and a sensor-based state provider with different
 sensor configurations.
 This was not only useful during development, but also critical to accomplish
 the automated testing system described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Automated-Testing"

\end_inset

.
\end_layout

\begin_layout Subsection
Output Controller Class
\end_layout

\begin_layout Standard
The output controller is concerned with producing joystick output from the
 current state and the navigation command given by the autopilot.
 Helicopters are very hard to develop navigation logic for since they are
 unstable by nature and will quickly drift out of control.
 In this section we describe a few methods we developed that enabled the
 helicopter to maneuver safely.
 We assume a perfect state provider is used unless otherwise noted to leave
 the concerns of state inaccuracy out of the details.
 
\end_layout

\begin_layout Paragraph
En Route Command
\end_layout

\begin_layout Standard
The command we spent the most time developing logic for was for navigating
 from A to B.
 More accurately, this method is only concerned with getting to B from where
 it currently believe it is.
 One simplification we found natural to do was to think navigation in the
 horizontal plane, as if looking at map.
 We simplified any vertical navigation to the concept of ascending and descendin
g.
 By assuming the helicopter would always maintain near-level flight we could
 isolate this part to only control the throttle output.
 For navigation we then only needed to think in the horizontal plane and
 we will use the h-vector notation here to underline this.
 
\end_layout

\begin_layout Subparagraph
Throttle
\end_layout

\begin_layout Standard
The throttle control logic is very straight forward.
 As long as the pitch and roll angles are constrained to near level flight
 increasing the throttle will increase the upwards lift component.
 Controlling the throttle is then a matter of defining altitude error in
 the navigation frame as:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\tilde{y}=p_{d}-y\end{equation}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $p_{d}$
\end_inset

 helicopter altitude
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $y$
\end_inset

 target altitude
\end_layout

\begin_layout Standard
Our problem is now essentially to let 
\begin_inset Formula $\tilde{y}$
\end_inset

 approach zero to reach our target altitude.
 We assigned a PID-controller 
\begin_inset Formula $PID_{throttle}$
\end_inset

 to regulate this and we insert the altitude error into equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PID-controller"

\end_inset

 and get:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
PID_{throttle}=K_{P}\cdot\tilde{y}(t)+K_{I}\cdot\int\tilde{y}(t)dt+K_{D}\cdot\frac{d}{dt}\tilde{y}(t),\, PID_{throttle}\in\left[0,1\right]\end{equation}

\end_inset


\end_layout

\begin_layout Standard
To implement the equation we discretize into timesteps and formulate a recursive
 equation to compute the PID output.
 By accumulating the error in 
\begin_inset Formula $f_{n}$
\end_inset

 we only need store values for the current and the previous timestep.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{eqnarray*}
PID_{throttle} & = & K_{P}e_{n}+K_{I}f_{n}+K_{D}\frac{e_{n}-e_{n-1}}{t_{n}-t_{n-1}},\, PID_{throttle}\in\left[0,1\right]\\
e_{n} & = & \tilde{y}(n)\\
f_{n} & = & f_{n-1}+e_{n}\\
f_{0} & = & 0\\
n & \geq & 1\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $n$
\end_inset

 timestep
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $e_{n}$
\end_inset

 altitude error at timestep n
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $f_{n}$
\end_inset

 accumulated altitude error at timestep n
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $t_{n}$
\end_inset

 time at timestep n
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $K_{P}$
\end_inset

 proportional gain
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $K_{I}$
\end_inset

 integral gain
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $K_{D}$
\end_inset

 derivative gain
\end_layout

\begin_layout Standard
When the error 
\begin_inset Formula $e_{n}$
\end_inset

 is negative the helicopter is below its target altitude and the proportional
 term will apply a thrust to produce lift.
 Due to gravity we will typically not reach this altitude, because the lifting
 force by the proportional term is eventually outweighed by the force of
 gravity as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:Throttle_PD"

\end_inset

.
 As time passes the integral term will then accumulate enough error to raise
 the thrust just enough to reach the target altitude.
 If we configure the 
\begin_inset Formula $K_{P}$
\end_inset

 and 
\begin_inset Formula $K_{I}$
\end_inset

 gains aggressively to more quickly reach the target we are likely to overshoot
 the the target and oscillate back and forth across the target.
 The derivative term will then dampen this motion as a dampened spring and
 allows the helicopter to quickly and smoothly reach its target altitude
 and stay there as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:Throttle_PID"

\end_inset

.
 The PID settings used in the implementation are listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Autopilot-configuration-variables."

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[PD-controller: The proportional gain is not sufficient to overcome
 the constant gravity.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/Autopilot/ThrottleControl_PD.png
	height 5cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:Throttle_PD"

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
hspace{2mm}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[PID-controller: The integral term helps increase the throttle
 to overcome gravity .]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/Autopilot/ThrottleControl_PID.png
	height 5cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:Throttle_PID"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
PD- vs.
 PID-controller for altitude control loop.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subparagraph
Nose-On Navigation
\end_layout

\begin_layout Standard
Now that throttle control is out of the way we can concentrate on the horizontal
 navigation.
 The first method we attempted was 
\emph on
nose-on navigation
\emph default
.
 We realized that we could accelerate forwards in the horizontal plane by
 controlling the pitch angle.
 Applying negative pitch (nose down) was the equivalent of accelerating
 along the h-forward vector and we could direct this acceleration by yawing
 the nose to point where we wanted to go.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Nose-on-navigation-by"

\end_inset

 illustrates this.
 
\end_layout

\begin_layout Standard
The problem was that in most cases the helicopter starts with the nose pointing
 in an arbitrary direction.
 Since the helicopter must yaw the nose towards the goal the acceleration
 vector will lag behind and often be directed off the target.
 The faster the helicopter was configured to move the larger this error
 became and it often missed the waypoint radius entirely.
 In addition, if the helicopter overshot its waypoint position it had to
 turn 
\begin_inset Formula $180\degree$
\end_inset

 in order to accelerate in the opposite direction.
 This would typically oscillate back and forth around the waypoint and never
 come to rest.
 For sensor-based state providers this method performed particularly bad
 due to jumps in the estimated position.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/NoseOnNav.png
	width 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Nose-on navigation by yawing and pitching.
\begin_inset CommandInset label
LatexCommand label
name "fig:Nose-on-navigation-by"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Acceleration Controlled Cyclic Navigation
\end_layout

\begin_layout Standard
A far better method that we implemented used 
\emph on
cyclic navigation
\emph default
.
 The idea was that it is possible to navigate horizontally using pitch and
 roll, described in 
\begin_inset CommandInset citation
LatexCommand cite
key "a2ds_project"

\end_inset

 as the 
\emph on
cyclic controls
\emph default
.
 Pointing the nose in a particular direction is not necessary for maneuvering
 a helicopter.
 This method was slightly more intricate as we needed to transform our desired
 acceleration vector 
\begin_inset Formula $\mathbf{a}_{desired}$
\end_inset

 towards the target into a combination of desired pitch and roll angles
 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Cyclic-navigation-by"

\end_inset

.
 First we define the position error in body frame as 
\begin_inset Formula $\tilde{p}_{fwd}$
\end_inset

 and 
\begin_inset Formula $\tilde{p}_{right}$
\end_inset

 by projecting the position error vector
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{\tilde{p}}=\mathbf{p}-\mathbf{p}_{target}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
onto the body frame basis vectors frame basis vectors 
\begin_inset Formula $\mathbf{e}_{fwd}$
\end_inset

 and 
\series bold

\begin_inset Formula $\mathbf{e}_{right}$
\end_inset


\series default
 by the scalar projection function:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\tilde{p}_{fwd}=project(\mathbf{\tilde{p}},\,\mathbf{e}_{fwd})\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\tilde{p}_{right}=project(\mathbf{\tilde{p}},\,\mathbf{e}_{right})\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/AccelerationCyclicNav.png
	width 8cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Cyclic navigation by pitching and rolling to accelerate in the horizontal
 plane.
\begin_inset CommandInset label
LatexCommand label
name "fig:Cyclic-navigation-by"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we have formulated our problem to minimize the errors 
\begin_inset Formula $\tilde{p}_{fwd}$
\end_inset

 and 
\begin_inset Formula $\tilde{p}_{right}$
\end_inset

 in order to reach our target position.
 We then assign two PID-controllers 
\begin_inset Formula $PID_{pitch}$
\end_inset

 and 
\begin_inset Formula $PID_{roll}$
\end_inset

 to control the pitch and roll angles so that the resulting 
\emph on
acceleration
\emph default
 minimizes the body frame position error.
 From the PID equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PID-controller"

\end_inset

 we define our pitch and roll PID outputs:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
PID_{accel,fwd}=K_{P}\cdot\tilde{p}_{fwd}+K_{D}\cdot\frac{inv_{fwd}\cdot\triangle\tilde{p}_{fwd}}{\triangle t},\, PID_{accel,fwd}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{accel,right}=K_{P}\cdot\tilde{p}_{right}+K_{D}\cdot\frac{inv_{right}\cdot\triangle\tilde{p}_{right}}{\triangle t},\, PID_{accel,right}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
inv_{fwd}=\begin{cases}
\tilde{p}_{fwd}\geq0, & 1\\
\tilde{p}_{fwd}<0, & -1\end{cases}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
inv_{right}=\begin{cases}
\tilde{p}_{right}\geq0, & 1\\
\tilde{p}_{right}<0, & -1\end{cases}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We interpret the proportional term so that the greater the distance to the
 target, the more it will attempt to increase pitch and roll angles to accelerat
e towards it.
 The derivative term will dampen the approach to avoid overshoot by decelerating
 the helicopter as the proportional term becomes less significant.
 The inverse factors are needed because acccelerating when the target is
 in front (positive forward error) requires a negative pitch angle (nose
 down) and when the target is behind the helicopter (negative forward error)
 it must be positive (nose up).
 The same concept applies to roll.
 The integral term is not used and is omitted here.
\end_layout

\begin_layout Standard
The PID outputs are clamped to 
\begin_inset Formula $-1$
\end_inset

 and 1.
 If we consider the PID output as a desire to accelerate along each axis,
 with 1 and -1 being maximum acceleration in either direction along the
 axis, then we can simply multiply this value by some maximum angle to obtain
 our pitch and roll target angles.
 The yaw angle is not necessary for navigation and omitted here.
 The target angles are then fed into a P-controller that applies the proper
 joystick outputs to correct the pitch and roll angles.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\beta_{target}=\beta_{MAX}\cdot PID_{accel,fwd},\,\beta_{target}\in\left[-\beta_{MAX},\beta_{MAX}\right]\label{eq:PID-to-pitch-angle}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\psi_{target}=\psi_{MAX}\cdot PID_{accel,right},\,\psi_{target}\in\left[-\psi_{MAX},\psi_{MAX}\right]\label{eq:PID-to-roll-angle}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{pitch}=K_{P}\cdot(\beta-\beta_{target}),\, PID_{pitch}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{roll}=K_{P}\cdot(\psi-\psi_{target}),\, PID_{roll}\in\left[-1,1\right]\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We already specified that max throttle would produce a lifting force of
 1.7G.
 We wanted to preserve a vertical lift force component of 1.5G at all times
 and from 
\begin_inset Formula $1.7G\cos^{2}\theta=1.5G$
\end_inset

 we find that the pitch and roll angles should never exceed 
\begin_inset Formula $20\degree$
\end_inset

.
 In our implementation we used 
\begin_inset Formula $10\degree$
\end_inset

 to be on the safe side.
 When the helicopter was far away from its target it would pitch and roll
 up to 
\begin_inset Formula $10\degree$
\end_inset

 to gain speed towards the target.
 As it approached its destination the derivative term would gradually become
 dominant and decelerate the helicopter until it came to rest at its target.
 We successfully achieved nose-independent navigation using this method
 and proved this by forcing the helicopter to continuously yaw clockwise
 while navigating through waypoints.
\end_layout

\begin_layout Subparagraph
Velocity Controlled Cyclic Navigation
\end_layout

\begin_layout Standard
The cyclic navigation method did perform well for large parts of the project,
 but later we wanted to challenge the autopilot precision by decreasing
 the radius of the waypoints and hovering at fixed positions.
 That is when we discovered that our method would often miss the waypoints
 slightly and would never seem to come to a full stop, but rather move around
 the spot in a circular motion.
\end_layout

\begin_layout Standard
Both problems are related to the fact that we are always accelerating 
\emph on
towards
\emph default
 the target position.
 Although it seemed like a good idea at first it became evident that this
 was the same as a particle attached to a pivot by a string.
 If the particle has a velocity then the string acts a centripetal force
 on the particle towards the pivot, equivalent to our acceleration by pitch
 and roll towards the target.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Accelerating-towards-the"

\end_inset

 shows how this acceleration becomes orthogonal to the circular motion velocity
 and that is why it will keep circling the target.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/CircularMotionAroundTarget.png
	width 15cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Accelerating towards the target results in circular motions near the target.
\begin_inset CommandInset label
LatexCommand label
name "fig:Accelerating-towards-the"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our final method overcomes this problem by realizing that we need to control
 our position in terms of desired 
\emph on
velocity
\emph default
 and not the desired acceleration.
 An overview of this method is illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overview-autopilot-pids"

\end_inset

.
 We reformulate our problem so that we want our h-velocity vector 
\begin_inset Formula $\mathbf{v}$
\end_inset

 to point towards the target.
 First we define velocity error in body frame as 
\begin_inset Formula $\tilde{v}_{fwd}$
\end_inset

 and 
\begin_inset Formula $\tilde{v}_{right}$
\end_inset

 by projecting the navigation frame velocity error
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{\tilde{v}}=\mathbf{v}-\mathbf{v}_{desired}=\mathbf{v}-v_{nav}\frac{\mathbf{p}_{goal}-\mathbf{p}}{\left|\mathbf{p}_{goal}-\mathbf{p}\right|}=\mathbf{v}-v_{nav}\frac{-\tilde{\mathbf{p}}}{\left|-\tilde{\mathbf{p}}\right|}=\mathbf{v}+v_{nav}\frac{\tilde{\mathbf{p}}}{\left|\tilde{\mathbf{p}}\right|}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
onto the body frame basis vectors frame basis vectors 
\begin_inset Formula $\mathbf{e}_{fwd}$
\end_inset

 and 
\series bold

\begin_inset Formula $\mathbf{e}_{right}$
\end_inset


\series default
 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pitch-and-roll-velocity-controlled"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\tilde{v}_{fwd}=project(\tilde{\mathbf{v}},\,\mathbf{e}_{fwd})\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\tilde{v}_{right}=project(\tilde{\mathbf{v}},\,\mathbf{e}_{right})\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Autopilot/VelocityControlledNav.png
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pitch and roll is controlled to minimize the error velocities 
\begin_inset Formula $\tilde{v}_{fwd}$
\end_inset

 and 
\begin_inset Formula $\tilde{v}_{right}$
\end_inset

 to get 
\begin_inset Formula $\mathbf{v}$
\end_inset

 to approach 
\begin_inset Formula $\mathbf{v}_{desired}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:Pitch-and-roll-velocity-controlled"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition to directing our velocity vector towards the target we also
 need to specify how fast we should be moving towards it.
 We used a simple algorithm where the desired velocity magnitude 
\begin_inset Formula $\left|\mathbf{v}_{desired}\right|$
\end_inset

 was a linear function of distance and clamped at a max horizontal speed
 
\begin_inset Formula $v_{h,max}$
\end_inset

.
 This way we could smoothly decelerate the helicopter the last few meters
 towards the target.
\end_layout

\begin_layout Standard
Similar to our previous method we have formulated our problem to let errors
 
\begin_inset Formula $\tilde{v}_{fwd}$
\end_inset

 and 
\begin_inset Formula $\tilde{v}_{right}$
\end_inset

 approach zero in order to reach our target position.
 Again we use PID-controllers, but this time we want to direct our 
\emph on
velocity
\emph default
 towards the target by controlling the pitch and roll angles.
 From equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PID-controller"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PID-to-pitch-angle"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:PID-to-roll-angle"

\end_inset

 we get equations for our target pitch and roll angles.
 The target angles are then fed into a P-controller that applies the proper
 joystick outputs to correct the pitch and roll angles.
 The P-controller for the optional yaw control is also listed here.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
PID_{velocity,fwd}=K_{P}\cdot\tilde{v}_{fwd},\, PID_{velocity,fwd}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{velocity,right}=K_{P}\cdot\tilde{v}_{right},\, PID_{velocity,right}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\beta_{target}=\beta_{MAX}\cdot PID_{velocity,fwd},\,\beta_{target}\in\left[-\beta_{MAX},\beta_{MAX}\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
\psi_{target}=\psi_{MAX}\cdot PID_{velocity,right},\,\psi_{target}\in\left[-\psi_{MAX},\psi_{MAX}\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{pitch}=K_{P}\cdot(\beta-\beta_{target}),\, PID_{pitch}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{roll}=K_{P}\cdot(\psi-\psi_{target}),\, PID_{roll}\in\left[-1,1\right]\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
PID_{yaw}=K_{P}\cdot(\alpha-\alpha_{target}),\, PID_{yaw}\in\left[-1,1\right]\end{equation}

\end_inset


\end_layout

\begin_layout Standard
With this method the integral and derivative terms are not required to control
 the pitch and roll angles since the velocity function will ensure that
 the helicopter approaches the target quickly and smoothly.
 Also, as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Physics"

\end_inset

, the orientation of the model helicopter is quite stable and will quickly
 damp angular velocity on its own.
 This means that a simple P-controller should be able to control the pitch,
 roll and yaw angles with very little oscillation.
 The yaw angle is also controlled by the autopilot, but it is not required
 for navigation and omitted here.
 
\end_layout

\begin_layout Subparagraph
Scalar Projection Function
\end_layout

\begin_layout Standard
Our scalar projection function 
\begin_inset Formula $project(\mathbf{a},\,\mathbf{b})$
\end_inset

 returns the length of 
\begin_inset Formula $\mathbf{a}$
\end_inset

 projected onto 
\begin_inset Formula $\mathbf{b}$
\end_inset

.
 The dot product for three dimensional vectors is defined by 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\mathbf{a}\cdot\mathbf{b}=a_{x}b_{x}+a_{y}b_{y}+a_{z}b_{z}$
\end_inset

 and its geometric interpretation 
\begin_inset Formula $\mathbf{a}\cdot\mathbf{b}=\left|\mathbf{a}\right|\left|\mathbf{b}\right|\cos\theta$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 It is readily seen that our scalar projection is defined by the length
 of 
\begin_inset Formula $\vec{\mathbf{a}}$
\end_inset

 and its angle 
\begin_inset Formula $\theta$
\end_inset

 to 
\begin_inset Formula $\mathbf{b}$
\end_inset

: 
\begin_inset Formula \begin{equation}
project(\mathbf{a},\,\mathbf{b})=\left|\mathbf{a}\right|\cos\theta\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We shuffle the above equations and obtain the scalar projection function.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
project(\mathbf{a},\,\mathbf{b})=\frac{\mathbf{a}\cdot\mathbf{b}}{\left|\mathbf{b}\right|}=\frac{a_{x}b_{x}+a_{y}b_{y}+a_{z}b_{z}}{\left|\mathbf{b}\right|}\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Hover Command
\end_layout

\begin_layout Standard
Our initial attempts to hover at a position was to tell the output controller
 to maintain level flight (
\begin_inset Formula $\alpha=0,\beta=0$
\end_inset

) and to maintain the current altitude.
 The problem was that if the helicopter already had a velocity the helicopter
 would move a long distance before drag dampened the motion to a full stop.
 Fortunately, once we had a working method for navigation then hovering
 became very simple.
 We now simply tell the output controller to move to the position we were
 at the time the command was issued and let the navigation method deal with
 all the details.
\end_layout

\begin_layout Paragraph
Recovery Command
\end_layout

\begin_layout Standard
The implementation for this command is also very simple.
 Assuming the recovery command is issued if there is an immediate danger
 of crashing into the ground we simply tell the output controller to maintain
 level flight (
\begin_inset Formula $\alpha=0,\,\beta=0$
\end_inset

) and to maintain full throttle.
 Hopefully this will generate enough lift to prevent the crash.
 Obviously there are more elegant solutions, such as avoiding trees and
 walls, but in our simple terrain navigation scenarios this worked well.
\end_layout

\begin_layout Subsection
Autopilot Assisted Control
\end_layout

\begin_layout Standard
The autopilot assisted control (AAC) was a concept we came up with when
 we observed that most persons attempting manual flight in our simulator
 ended up crashing a lot.
 We realized that having a working autopilot made it possible to let the
 autopilot handle all the details of keeping the helicopter stable and simply
 follow navigational commands of the user on where to go.
 This would enable persons with no flying experience to maneuver the helicopter
 safely and efficiently.
 We already had a working method for autonomous flight so adding assisted
 control was simply a matter of extending our method to accept joystick
 commands from the user.
\end_layout

\begin_layout Standard
We designed the AAC so that if the joystick was let go the helicopter would
 safely come to a hover at its current position in the air.
 Holding the joystick forwards would make the helicopter move forwards and
 the same for sideways and backwards.
 The joystick throttle slider was used to tell the autopilot what altitude
 above the ground to maintain and the yaw controls (pedals) were used change
 the direction of the helicopter nose during flight.
\end_layout

\begin_layout Standard
By extending our velocity controlled cyclic navigation method we only had
 to convert joystick outputs into values for desired velocity vector 
\begin_inset Formula $\mathbf{v}_{desired}$
\end_inset

, target height above the ground 
\begin_inset Formula $y$
\end_inset

 and heading angle 
\begin_inset Formula $\psi$
\end_inset

.
 Our navigation method already had PID configurations to let the autopilot
 maneuver the helicopter accordingly so the implementation of AAC was straight
 forward.
 Initial tests in our simulation indicated that with sufficiently accurate
 state estimates the users were almost unable to crash the helicopter.
 We observed safe flights as low as 2 meters above the ground at speeds
 up to 36 km/h over curved terrains when there were no trees or obstacles
 to crash in.
\end_layout

\begin_layout Subsection
PID Settings
\end_layout

\begin_layout Standard
The output controller relies largely on the use of PID-controllers to control
 the motion of the helicopter.
 For this to work we must accurately tune the PID settings to fit the flight
 dynamics of the helicopter to achieve safe and smooth navigation.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Control-Theory"

\end_inset

 we discussed methods to tune the PID coefficients so that the helicopter
 reaches its destination quickly with minimal overshoot and oscillation.
 Since we were in a simulator environment we found that the most effective
 way of tuning the coefficients was by trial and error so we developed a
 GUI component (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PID-settings-configuration"

\end_inset

) that let us manipulate the PID settings during autonomous navigation to
 see the effects on-the-fly.
 Also, given a sufficiently accurate sensor and physics simulation this
 should provide a good starting point for real flight experiments in future
 applications.
 The final PID settings used in our experiments are found in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Autopilot-configuration-variables."

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/PID_settings_dialog.png
	width 10cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
PID settings configuration dialog.
\begin_inset CommandInset label
LatexCommand label
name "fig:PID-settings-configuration"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Automated Testing
\begin_inset CommandInset label
LatexCommand label
name "sec:Automated-Testing"

\end_inset


\end_layout

\begin_layout Standard
The experiments we performed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Test-Results"

\end_inset

 required us to test a large number of combinations of autopilot settings,
 sensor specifications, navigation tasks and terrain configurations.
 Having to re-compile or change configuration files for each combination
 was not an option so we implemented an automated testing system.
 
\end_layout

\begin_layout Standard
A test configuration file as described in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TestConfiguration.xml"

\end_inset

 lists a set of test scenarios and a set of autopilot settings.
 The scenarios are also defined in a configuration file as described in
 appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Scenarios.xml"

\end_inset

 and holds all the remaining information about starting state, sensors,
 navigation, terrain and world objects to be loaded.
 Each scenario is then run a number of times to test out all the autopilot
 settings for that scenario.
 The test scenario ends when the helicopter crashes, completes the navigation
 task or exceeds the timeout limit and a flight log is exported to file
 for review.
 These logs were then used to present the results in the experiments section.
\end_layout

\begin_layout Section
Portability to Embedded Solutions
\end_layout

\begin_layout Standard
It was the intention that any autopilot logic developed in this simulator
 should be easily portable to a microcontroller for real navigation in future
 applications.
 We noted this in the software architecture design in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Software-Architecture"

\end_inset

 by requirement R6 that said the autopilot program code and its dependencies
 should be portable to the programming language C.
 There were a number of tactics (T1-T4) that helped achieve this, such as
 minimizing simulator and platform dependencies and isolating the autopilot
 code to a black box with inputs and outputs.
 The only dependencies of our autopilot code is an open source matrix math
 library and a few references to data structures for helicopter state and
 sensor configurations; so we consider the requirement to be met.
\end_layout

\begin_layout Section
Audio
\end_layout

\begin_layout Standard
XNA has native support for sound effects and music.
 One can either load audio files directly or use XACT, the included audio
 tool for creating banks of sounds and adding effects to the sounds.
\end_layout

\begin_layout Standard
We created an engine sound by extracting a three second audio clip from
 a recording of a helicopter engine running at a fixed speed.
 With some careful edge-trimming the clip could be looped to create a continuous
 engine sound without hearing the loop points.
 To give an illusion of the engine running faster when applying throttle
 we used the XNA audio framework to modify the audio pitch on the fly.
 Raising the pitch by a few notes gave the impression of the engine speeding
 up and the end result was quite believable.
\end_layout

\begin_layout Section
Joystick Support
\end_layout

\begin_layout Standard
XNA supports mouse, keyboard and gamepads, but not joysticks.
 To achieve this we interfaced with the DirectInput framework of DirectX.
 In the early stages of our implementation we reused an open source component
 to read the the axis and button outputs, but when the lab introduced the
 Logitech G940 Flight System we ran into an issue.
 The joystick had 9 joystick axes, 9 axis trims and a large number of buttons
 and HAT-switches.
 Any single DirectInput device cannot support more than 8 analog values
 used for axes and trims so this is why the G940 system is detected as three
 separate game controllers; joystick, throttle and pedals.
\end_layout

\begin_layout Standard
First we had to write our own JoystickSystem class to handle multiple joystick
 devices.
 Second there was a need to keep the mapping of functions to different buttons
 and axes of a joystick in a separate file.
 Third we had to create a small application to help configure the mapping.
 We started on creating a wizard to aid the user in setting up a new joystick,
 but this took a lot of time so figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "subfig:Wizard-application-for"

\end_inset

 shows how we instead list all the connected devices and show their live
 outputs.
 Mapping the joystick is then a matter of assigning function names to the
 corresponding axis names in the configuration file, explained in detail
 in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-ConfigurationFiles"

\end_inset

.
 This way our implementation supports any PC joystick no matter what axes
 or number of devices it has.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[Logitech G940 Flight System]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/Logitech_G940.JPG
	lyxscale 50
	width 12cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:G940"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subfigure[Application for mapping functions to axes and buttons.]{
\end_layout

\end_inset


\begin_inset Graphics
	filename Figures/joystick_wizard.png
	lyxscale 50
	width 12cm

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subfig:Wizard-application-for"

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The G940 joystick system required us to create a joystick configuration
 application.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Results
\begin_inset CommandInset label
LatexCommand label
name "cha:Results"

\end_inset


\end_layout

\begin_layout Standard
As a proof of concept we conducted autonomous flight experiments with different
 levels of state knowledge, from full simulation knowledge to state estimates
 with realistically modelled IMU and GPS sensors.
 In this section we list the results of the experiments and all the computer
 and configuration details required to reproduce them.
\end_layout

\begin_layout Section
Computer Configuration
\begin_inset CommandInset label
LatexCommand label
name "sec:Computer-Configuration"

\end_inset


\end_layout

\begin_layout Standard
Below is the test computer setup we used to produce the results in our flight
 experiments.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
OS: Windows Vista™ Business 64-bit
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
CPU: Intel® Core™ i7 920 @ 2.66 GHz
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
GPU: NVIDIA® Quadro® FX 5600 4GB
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Memory: 12GB
\end_layout

\begin_layout Section
Autopilot Configuration
\end_layout

\begin_layout Standard
The autopilot configuration variables used throughout the experiments are
 listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Autopilot-configuration-variables."

\end_inset

.
 Note that some variables are defined in code and are not readily configurable.
 The velocity controlled cyclic navigation method in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Autopilot-Logic"

\end_inset

 was used throughout all the experiments.
 The sensor configurations are defined in their respective experiment sections.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Conf.
 Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $\beta_{MAX}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\degree$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max pitch angle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $\psi_{MAX}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\degree$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max roll angle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HAG
\begin_inset Formula $_{target}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target height above ground.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v_{h,max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.6 - 36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max horizontal velocity.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t_{dec}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deceleration reaction time.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $s_{dec}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $t_{dec}\cdot v_{h,max}$
\end_inset

 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distance to start decelerating.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $r_{max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\begin_inset Foot
status open

\begin_layout Plain Layout
The precision scenario uses 0.5 m.
\end_layout

\end_inset

 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max distance to pass a waypoint.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PID_{pitch}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P=30,\, I=0,\, D=0$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
The actual coefficients are inverted, such as 
\begin_inset Formula $K_{P}=\frac{1}{P}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PID settings for pitch angle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PID_{roll}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P=30,\, I=0,\, D=0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PID settings for roll angle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PID_{yaw}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P=30,\, I=0,\, D=0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PID settings for yaw angle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PID_{throttle}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P=-0.5,\, I=-0.5,\, D=-1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PID settings for throttle.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PID_{velocity}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $P=-1,\, I=0,\, D=0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PID settings for velocity.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The autopilot configuration used in experiments.
\begin_inset CommandInset label
LatexCommand label
name "tab:Autopilot-configuration-variables."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Flight Experiments
\begin_inset CommandInset label
LatexCommand label
name "sec:Flight-Experiments"

\end_inset


\end_layout

\begin_layout Paragraph
Configuration 1: Perfect Knowledge
\end_layout

\begin_layout Standard
The first experiment we designed gave the autopilot direct insight to the
 simulation information.
 This means the helicopter knew its exact position and orientation in the
 virtual world and the autopilot performance was only limited by the autopilot
 logic itself.
 This way we set the bar for the optimal autopilot performance and any deviation
 from these results would be a direct consequence of having to estimate
 the state from uncertain information.
 This configuration was also used to verify that the INS had zero deviation
 when its IMU sensor data was perfect.
 The results are listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Test-results-scenario1"

\end_inset

.
 Since no sensors were involved for navigation we omit the sensor specifications
 here.
 
\end_layout

\begin_layout Paragraph
Configuration 2: Perfect Sensors
\end_layout

\begin_layout Standard
The second experiment was designed to reveal the effects of precision issues
 when transforming between reference frames.
 We have eliminated any noise in the sensors and set the accelerometer to
 sample infinitely fast (once every simulation timestep).
 Only the INS estimate was used so the GPS and range finder measurements
 were ignored to isolate the error sources to the loss of precision when
 transforming simulated measurements between navigation and body reference
 frames, as described in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-PrecisionIssues"

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Specification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS Freq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Position RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Velocity RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inf.
 Hz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Fwd.
 RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Right RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Up RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range Finder RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INS Euler Angle RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\begin_inset Formula $\degree$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sensor specifications for experiment 2.
\begin_inset CommandInset label
LatexCommand label
name "tab:Sensor-specifications-ex2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Configuration 3: Datasheet Sensors
\end_layout

\begin_layout Standard
This experiment was designed to let the autopilot navigate by realistic
 magnitudes of sensor noise and state uncertainty.
 We used the sensor specifications from the datasheets directly as outlined
 in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sensor-specifications-ex3"

\end_inset

.
 Since we did not use angular velocity measurements to filter orientation
 we approximated this uncertainty by periodically adding a random offset
 to the INS yaw, pitch and roll angles.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Specification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS Freq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 Hz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Position RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.9 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Velocity RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05 m/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60 Hz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Fwd.
 RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0071 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Right RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0071 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Up RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0089 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range Finder RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.025 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INS Euler Angle RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\begin_inset Formula $\degree$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sensor specifications for experiment 3.
\begin_inset CommandInset label
LatexCommand label
name "tab:Sensor-specifications-ex3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Configuration 4: Unreliable Sensors
\end_layout

\begin_layout Standard
The final experiment challenges the autopilot with very high noise levels
 to see the effects on state estimation and flight behavior.
 The sensor specifications were simply chosen by increasing the errors in
 the datasheet specifications.
 An interesting point was to halve the accelerometer sampling rate to undersampl
e the truth just as real sensors would.
 The noise in the orientation estimate was also doubled to promote uncertainty
 in the INS estimate.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Specification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS Freq.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 Hz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Position RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS 3D Velocity RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 m/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30 Hz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Fwd.
 RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.71 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Right RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.71 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accelerometer Up RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.89 g
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range Finder RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INS Euler Angle RMS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\begin_inset Formula $\degree$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sensor specifications for experiment 4.
\begin_inset CommandInset label
LatexCommand label
name "tab:Sensor-specifications-ex4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Navigation Scenarios
\end_layout

\begin_layout Standard
Each experiment runs through a set of test scenarios that describes the
 navigation task and the terrain configuration.
 Each test scenario will only succeed if the helicopter reaches its destination
 before timeout and without crashing.
 If the helicopter crashes the autopilot will try a number of lesser 
\begin_inset Formula $v_{h,max}$
\end_inset

 configurations until it succeeds.
 If none of them succeeds the test scenario is marked as failed.
 The complete list of test scenarios and their configurations are listed
 in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TestConfiguration.xml"

\end_inset

.
 
\end_layout

\begin_layout Paragraph
Outline of Scenarios
\end_layout

\begin_layout Standard
Each scenario is presented here by a short description and a figure that
 illustrates the navigation task by visual flight logs.
 The scale of the navigation tasks makes it impractical to present any details
 and many of the lines are not distinguishable, so the intention of the
 figures is merely to give an overview of the different navigation scenarios.
 Each scenario has three graphs that show the horizontal navigation, the
 altitude over time and the measured acceleration over time.
 A legend for the graphs is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Legend-for-flight"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Kalman Filter output/FlightLogLegend.png
	lyxscale 50
	height 6cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Legend for flight log graphs.
\begin_inset CommandInset label
LatexCommand label
name "fig:Legend-for-flight"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenario 1: A-B Short Flat
\end_layout

\begin_layout Standard
This is the simplest scenario, which involves a short straight navigation
 from A to B over flat ground.
 It is expected that all experiments will pass this scenario unless the
 noise levels are increased beyond realistic levels.
 See outline in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flightlog-scenario1-ex3"

\end_inset

.
\end_layout

\begin_layout Subsection
Scenario 2: Circle Medium Sloped
\end_layout

\begin_layout Standard
This is the most realistic navigation scenario, which involves passing four
 waypoints placed in a wide circle.
 The terrain has significant curvature and the length of navigation is almost
 200 meters.
 The difficulty of passing this scenario is considered medium, but passable
 for realistically modelled sensors or better.
 See outline in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flightlog-scenario2-ex3"

\end_inset

.
\end_layout

\begin_layout Subsection
Scenario 3: Circle Large Hilly
\end_layout

\begin_layout Standard
This is a very difficult scenario designed to challenge the autopilot.
 The circle is over 300 meters and the terrain is much steeper so we did
 not expect sensor-based autopilots to be able to pass this one.
 See outline in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flightlog-scenario3-ex3"

\end_inset

.
\end_layout

\begin_layout Subsection
Scenario 4: Circle Precision Short Flat
\end_layout

\begin_layout Standard
This is also an artificially difficult scenario designed to challenge the
 precision of the autopilot.
 While all the other scenarios uses 5 m waypoint radiuses this one uses
 0.5 m.
 The navigation needs to be very accurate and we did not expect sensor based
 experiments to pass this.
 See outline in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flightlog-scenario4-ex3"

\end_inset

.
\end_layout

\begin_layout Section
Test Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Test-Results"

\end_inset


\end_layout

\begin_layout Standard
This section describes the results of the flight experiments we conducted
 on the four test scenarios.
 The experiments were designed to measure the impact of unreliable knowledge
 in the autopilot performance over different navigation scenarios.
 We conducted four experiments ranging from perfect simulation knowledge
 to poor sensor data and the results are listed in tables 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Test-results-scenario1"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Test-results-scenario4"

\end_inset

 and figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flight-logs-scenario1"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Flight-logs-scenario4"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Legg til tidsmerker på figurene for å vise kobling mellom posisjon
 og tidsgrafer.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 1/A-B Short Flat_10mps_pos.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 1/A-B Short Flat_10mps_height.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 1/A-B Short Flat_10mps_accel.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Outline of scenario by flight log from configuration #3 in scenario #1.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flightlog-scenario1-ex3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 2/Circle Medium Sloped_10mps_pos.PNG
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 2/Circle Medium Sloped_10mps_height.PNG
	lyxscale 50
	width 15cm
	rotateOrigin centerTop

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 2/Circle Medium Sloped_10mps_accel.PNG
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Outline of scenario by flight log from configuration #3 in scenario #2.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flightlog-scenario2-ex3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 3/Circle Large Hilly_5mps_pos.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 3/Circle Large Hilly_5mps_height.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 3/Circle Large Hilly_5mps_accel.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Outline of scenario by flight log from configuration #3 in scenario #3.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flightlog-scenario3-ex3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 4/Circle Precision Short Flat_10mps_pos.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 4/Circle Precision Short Flat_10mps_height.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/scenario 4/Circle Precision Short Flat_10mps_accel.png
	lyxscale 50
	width 15cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Outline of scenario by flight log from configuration #3 in scenario #4.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flightlog-scenario4-ex3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Results of Scenario 1
\begin_inset CommandInset label
LatexCommand label
name "sec:Results-Scenario1"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Configuration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Passed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Duration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.7 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.7 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.5 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.9 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attempts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final 
\begin_inset Formula $v_{h,max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.01 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.98 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.98 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.98 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.98 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.93 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.93 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.92 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.93 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.22 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.35 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.53 m
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results of experiments on test scenario 1.
\begin_inset CommandInset label
LatexCommand label
name "tab:Test-results-scenario1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/Comparison/scenario1_comparison.png
	lyxscale 25
	height 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Flight logs from experiments on scenario 1.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flight-logs-scenario1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Results of Scenario 2
\begin_inset CommandInset label
LatexCommand label
name "sec:Results-Scenario2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Configuration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Passed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Duration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29.8 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29.8 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29.7 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40.8 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attempts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final 
\begin_inset Formula $v_{h,max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.27 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.29 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.64 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.95 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.04 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.02 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.70 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.69 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.18 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.71 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.55 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.83 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.3 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.62 m
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results of experiments on test scenario 2.
\begin_inset CommandInset label
LatexCommand label
name "tab:Test-results-scenario2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/Comparison/scenario2_comparison.png
	lyxscale 25
	height 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Flight logs from experiments on scenario 2.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flight-logs-scenario2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Results of Scenario 3
\begin_inset CommandInset label
LatexCommand label
name "sec:Results-Scenario3"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Configuration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Passed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Duration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
63.3 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
63.3 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
63.0 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81.5 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attempts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final 
\begin_inset Formula $v_{h,max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.17 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.24 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.53 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.84 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.15 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.07 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.67 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.61 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.40 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.90 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.48 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.65 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.49 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.35 m
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results of experiments on test scenario 3.
\begin_inset CommandInset label
LatexCommand label
name "tab:Test-results-scenario3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/Comparison/scenario3_comparison.png
	lyxscale 25
	height 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Flight logs from experiments on scenario 3.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flight-logs-scenario3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Results of Scenario 4
\begin_inset CommandInset label
LatexCommand label
name "sec:Results-Scenario4"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Configuration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
#4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Passed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Duration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.8 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.8 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.5 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timed out
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Attempts
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final 
\begin_inset Formula $v_{h,max}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 km/h
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 km/h
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.01 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.01 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.01 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.01 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.99 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.99 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.99 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.00 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min HAG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.93 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.93 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.92 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.92 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.19 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.31 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Avg.
 pos.
 est.
 err.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.08 m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.88 m
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Results of experiments on test scenario 4.
\begin_inset CommandInset label
LatexCommand label
name "tab:Test-results-scenario4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Figures/Flightlogs/Comparison/scenario4_comparison.png
	lyxscale 25
	height 12cm

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Flight logs from experiments on scenario 4.
\begin_inset CommandInset label
LatexCommand label
name "fig:Flight-logs-scenario4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter
Discussion
\begin_inset CommandInset label
LatexCommand label
name "cha:Discussion"

\end_inset


\end_layout

\begin_layout Standard
The proof-of-concept implementation employs methods from a number of disciplines
 and here we discuss the methods and choices made for each aspect of the
 software.
 We will use the test results from autonomous flight experiments to verify
 that we reached the goals we set out to achieve and we will discuss whether
 the results achieved here are realistic and applicable for real navigation
 scenarios.
\end_layout

\begin_layout Section
Software Architecture
\end_layout

\begin_layout Standard
The simulator was intended for future extensions so we decided it was important
 to design a proper software architecture and to document it.
 We put significant effort into promoting modifiability, performance and
 portability throughout the code and we consider 5 out of 6 requirements
 to be met.
 The physics and virtual sensor components can easily be extended or replaced
 with more accurate models later and the autopilot logic is portable from
 the simulator environment to a microcontroller solution with real sensors.
 Requirement R5 was only partially met, because it proved difficult to maintain
 real-time simulation with high-speed sensors running as fast as 100 Hz.
 We did, however, achieve different sensor sampling rates by downsampling
 the IMU and GPS measurements.
\end_layout

\begin_layout Standard
The focus was to develop a working prototype to investigate how the state
 estimation error was affected by different configurations of sensor noise
 and frequency.
 Since we were not going to port our autopilot to a microcontroller as a
 part of this thesis we did take some shortcuts.
 First, the GPS/INS Kalman filter uses a large math library to deal with
 matrix operations and this dependency is not directly portable to a microcontro
ller.
 Second, we did not take restrictions of a microcontroller solution into
 account when designing the state estimator and autopilot components.
 Issues such as state estimation performance and sampling timing were left
 out of the scope of this implementation.
\end_layout

\begin_layout Standard
An interesting side-effect of the architectural design was that it also
 promoted reusability of certain components.
 The OutputController class has few simulation dependencies and the control
 logic contained within it could be viable for reuse in the control of helicopte
rs in games.
 With properly tuned PID settings the AI would only need to provide navigational
 commands and the current world state of the game in order for the helicopter
 to move according to the AI planning.
 
\end_layout

\begin_layout Section
Visualization
\end_layout

\begin_layout Standard
We implemented a wide range of visualization techniques to add to the value
 of the implementation as both an autopilot development tool and a flight
 simulation application.
 The goal was to create believable and useful graphics that the user could
 relate to as an approximation to real flight in outdoor environments.
 In that aspect we feel we succeeded.
\end_layout

\begin_layout Standard
The visualization focused on representing the current position in the virtual
 world and to give the user a sense of scale and motion to make manual flight
 easier and to better observe the autopilot flight trajectories.
 The outdoor environment was accomplished by utilizing open source XNA component
s for terrains, trees and skydome rendering.
 We saved a lot of effort in using the XNA game framework here, which is
 designed to easily reuse XNA components and content created by others.
 Manual flight became a lot easier and much more fun after implementing
 the cockpit camera.
 The user could now fly as if sitting in a real cockpit and looking out
 the windows.
 In addition the head-tracking and stereoscopy rendering was both practical
 and an entertaining experience that is not available in PC games today.
\end_layout

\begin_layout Standard
Although the visualization is practical and intuitive it does lack in realism.
 The components we reused for outdoor rendering were designed for games
 and were fast, but simple and not very realistic.
 The trees alone were useful to give a sense of scale to the world, but
 the billboarding technique looked unnatural up close and we did not generate
 forests or formations of trees as one expects to find in the nature.
 Without growths and grass the terrain looks flat and artificial and it
 becomes more difficult to determine our velocity and the distance to certain
 objects when flying manually.
 We did reuse an open source sunlight shader and modified it to apply it
 to our terrain and world objects as if they were lit by the sun.
 Far away objects would then fade into the horizon color and this was both
 appealing and increased the realism, but as a serious game we would like
 to see more realistic skydomes with moving clouds, improved lighting and
 objects casting shadows to raise the visual standard to that of modern
 games.
\end_layout

\begin_layout Section
Physics Simulation
\end_layout

\begin_layout Standard
Due to time limitations we had to settle for a very simple flight dynamics
 model.
 Even so, we were satisfied with the overall feel of flying the helicopter
 by joystick and based on our own experience in flying model helicopters
 we considered it a good approximation.
 We will discuss the most prominent shortcomings here and suggest future
 enhancements.
 
\end_layout

\begin_layout Standard
One simplification we made was to omit torque and angular momentum.
 Instead we let angular velocity of the main rotor and the helicopter body
 be a direct function of joystick output.
 We justified this by the small scale and mass of model helicopters, but
 it is evident that incorporating moment would allow us to better model
 aerodynamic phenomena such as how the streamlined fuselage will rotate
 to align with the relative air flow from winds and high velocity flight.
 Modelling moment of inertia would allow us to more realistically simulate
 the way it takes time for an engine to accelerate and decelerate the main
 rotor to a certain rotor revolutions per minute.
 As we discovered when adding the Jitter physics engine to handle collisions
 it was hard to integrate with due to the way we simplified our angular
 motion, so to better support plug-in physics we need to model this properly.
 Finally, small model helicopters are very sensitive to gusts of winds and
 turbulence and it requires tight control to maintain safe and stable flight.
 It would be very interesting to challenge the autopilot with such conditions
 so that is another incentive to improve the physics simulation.
\end_layout

\begin_layout Standard
Although our physics simulation was very simple, it did behave much in the
 same manner as we expected it to.
 We consider the main limitations of our implementation as being too stable
 compared to our experience with real flight and that we did not compare
 the error in our flight behavior to videos of real helicopter flight where
 the joystick outputs were known.
 
\end_layout

\begin_layout Standard
We do not consider the current physics simulation to be sufficiently realistic,
 but adding a more accurate modelling of angular motion, inertia, winds
 and turbulence and comparing that flight behavior to real flights should
 go a long way on approaching a solution for real autopilot development.
\end_layout

\begin_layout Section
State Estimation
\end_layout

\begin_layout Standard
The state estimation method uses a Kalman filter to fuse measurements from
 the IMU and GPS sensors.
 This method is widely used for autonomous navigation applications and it
 can be proven that the filter provides an optimal estimate given certain
 assumptions of the sensors and the problem.
 The test results show that our implementation of the filter performed well
 and a lot better than trusting GPS or INS estimates alone.
 However, the Kalman filter is only suitable for estimating linear processes
 and this means we could not easily estimate orientation from IMU and digital
 compass measurements as we would like to.
 There was not enough time to implement this so we simplified the uncertainty
 of orientation.
 Having orientational uncertainty was necessary, because even just a few
 degrees of error in pitch or roll would quickly accumulate to large errors
 in position.
 Without this, the state estimation would become artificially accurate.
 
\end_layout

\begin_layout Standard
Another simplification we made was to model the range finder sensor without
 noise so that the height above the ground estimate in configurations 3
 and 4 would be limited to the inaccuracy of the sensor and the Flat Ground
 Height method proposed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Sensors"

\end_inset

.
 This was fair, because the datasheet did not specify noise for the range
 finder and since the FGH method was very inaccurate to start with.
 This way we avoided crashing so much since we were flying just a few meters
 from the ground in our test scenarios.
 Also, since the error was mainly horizontal we could compare our results
 to related work on GPS/INS filtering for land vehicles.
\end_layout

\begin_layout Standard
From the test results in configuration 1 we see that there was zero deviation
 in the state estimation when the sensor output was perfect and not subject
 to precision loss.
 All four scenarios verified this and we conclude that the estimation implementa
tion is valid.
 As we noted in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-Estimation-Impl"

\end_inset

, this was only true as long as we did not use the Jitter physics engine
 to handle collisions.
 Unfortunately, this also meant that we were not able to create scenarios
 that involved take-off and landing, because this would introduce significant
 estimation errors.
 In a future application this issue needs to be resolved for simulating
 realistic scenarios where helicopters start and stop on the ground.
\end_layout

\begin_layout Section
Autopilot Logic
\end_layout

\begin_layout Standard
In our implementation we proposed three different methods of maneuvering
 the helicopter from A to B.
 We could not find any academic material to base those methods on so the
 development was largely a process of trial and error.
 The final method, velocity controlled cyclic navigation, performed very
 well and the test results showed that it successfully completed a number
 of combinations of navigation scenarios and sensor configurations.
 It was designed to minimize overshoot by decelerating towards B and to
 minimize unwanted velocity components in order to hit the target dead on
 and avoid circular motion near the target position.
 Based on the simulation results we believe that this method is sound and
 stable for navigation with uncertain states and should be a good candidate
 for real autonomous flight experiments in the future.
\end_layout

\begin_layout Standard
An interesting possibility with a working autopilot is the concept of autopilot
 assisted control.
 Since helicopters are very unstable they require a lot of experience to
 fly safely.
 The autopilot could then enable persons with minimal training to maneuver
 the helicopter by commanding it to move forwards, sideways and to increase
 or decrease the height above the ground.
 The autopilot will then deal with all the effort required to maneuver the
 helicopter, hold it steady in windy conditions and avoid crashing.
 This should prove very useful for scenarios such as search operations where
 swarms of autonomous helicopters are sent out in the wild to look for missing
 people.
 The helicopters send live pictures back to a ground station monitored by
 human operators who can assume manual control over a helicopter to further
 investigate certain areas.
 We tested out our implementation of assisted control on people with no
 prior flying experience.
 In manual flight, most people would crash many times before getting to
 grips with the controls and the technique.
 With assisted control, they successfully flew the helicopter at high velocities
 and low altitudes over curved terrains without crashing.
\end_layout

\begin_layout Section
Flight Experiments
\end_layout

\begin_layout Standard
The experiments were designed to challenge both the autopilot control logic
 and the state estimation.
 When we designed the experiments and test scenarios we had certain expectations
 to what the results would look like.
 An autopilot with perfect knowledge should easily complete the navigation
 without crashing, while causing problems for autopilots with less accurate
 measurements.
 We then set out to investigate how lesser accurate knowledge performed
 and whether the specifications of cheap off-the-shelf sensors were sufficient
 for outdoor navigation.
\end_layout

\begin_layout Standard
We expected all four experiments to pass scenario 1 since it was very short
 and simple.
 This scenario was added to distinguish between configurations that were
 able to fly and those that did not fly at all.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Test-Results"

\end_inset

 lists all the test results and we see how all four experiments easily passed
 this scenario.
 Even the worst configured experiment performed satisfactory with a max
 estimation error of 1.35 m.
 This was natural since there is not enough time for the INS error to accumulate
 significantly.
 It should be noted that the altitude error is artificially accurate for
 all configurations, since we decided to ignore noise in the range finder
 implementation.
 The datasheet had no specifications on noise and this way we could concentrate
 on state estimation errors in the horizontal plane.
\end_layout

\begin_layout Standard
The second scenario was the most realistic navigation scenario.
 It featured curved terrains and the waypoints stretched for 200 m.
 We were uncertain whether our sensor based configurations would be able
 to pass this scenario since a lot of error will accumulate in the INS over
 30 seconds of navigation.
 This meant that the GPS/INS filter had to use the GPS observations more
 actively to prevent the INS position and velocity estimates from diverging
 significantly.
 The results show that the GPS/INS filter does indeed work as intended and
 the error does not diverge out of control.
 The datasheet sensors were only off by half a meter, while the unreliable
 sensors reached almost 7 meters of position inaccuracy.
 It can be seen from the flight log that the fourth experiment suffered
 so much from uncertainty that it missed the third waypoint and had to return
 back for it.
 
\end_layout

\begin_layout Standard
The third scenario featured extremely hilly terrain and we did not expect
 any sensor based configurations to complete it.
 As it turned out the scenario may have been overly difficult as even with
 perfect knowledge the autopilot did not manage to avoid crashing on the
 first attempt.
 The second attempt reduced the max horizontal speed from 36 to 18 km/h
 and this time experiments 1 and 2 completed without problem.
 To our surprise experiments 3 and 4 did so too.
 It seemed that the accurate range finder was working a little too well
 since it prevented all configurations from crashing even when their state
 was uncertain.
 On the other side, we see that both sensor based configurations were much
 more unstable in maintaining a height above the ground of 5 meters due
 to the error of the flat ground height method.
 Their HAG varied 7.13 and 7.94 meters respectively and scenario 4 was only
 90 cm shy of crashing into the ground, while scenarios 1 and 2 had variations
 of only 2.5 and 2.63 meters respectively despite moving as fast as 33 km/h
 across hilly terrains.
 Once more we see that scenario 4, due to its uncertainty of up to 9.65 m,
 had trouble hitting waypoints 2 and 3 and has to turn around to get within
 the radius of 5 m.
\end_layout

\begin_layout Standard
The fourth scenario featured precision navigation and required the helicopter
 to pass within 0.5 meters of the waypoints.
 We did not expect the sensor based configurations to successfully navigate
 all four waypoints, but the test results show that configuration 3 with
 datasheet sensors did pass this test.
 This might be due to the navigation spanning only 8 seconds, but then again
 in scenario 3 the datasheet configuration had an average accuracy of just
 0.49 meters over 63 seconds of navigation, which indicated its uncertainty
 would not grow too large to pass scenario 4.
 Configuration 4 failed as expected and timed out after 100 seconds.
 The flight log illustrates the chaotic flight pattern as it struggles to
 approach waypoint 3 when the error in the INS has accumulated so much that
 the GPS is not able to correct it sufficiently to get within the waypoint
 radius.
\end_layout

\begin_layout Standard
Overall we see that navigation by state estimation works very well, but
 seeing the results from using datasheet specifications in configuration
 3 we we suspect that the state estimation is performing unrealistically
 well.
 Comparing with the results of 
\begin_inset CommandInset citation
LatexCommand cite
key "gpsimu_fusion06"

\end_inset

 we see that they achieved an average of 0.81 m for a 300 second horizontal
 navigation scenario using similarly specified GPS and IMU sensors, while
 our test results showed an average with 0.49 m over 63 seconds where the
 contribution from vertical error was inherently small.
 We do not consider an improvement of 40% over related work to be realistic
 and this supports our suspicions that the state estimation may be performing
 too well.
 A few explanations are that the sensor specifications may be optimistic.
 In our own experience with GPS we have yet to see that 50% of the measurements
 fall within 3.3 meters.
 Also, as we explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Simulation-of-Sensors"

\end_inset

, the IMU sensors sampled each simulation time step so the measurements
 would not suffer from undersampling, which is the case for real sensors
 trying to sample real world processes.
 Finally the sensors are modelled by applying Gaussian noise, whereas real
 sensors will often have a bias and non-Gaussian noise.
 We tried to compensate for this by adding more noise and undersampling
 the IMU sensor in configuration 4 to get more realistic levels of uncertainty
 and as the test results show it was the only configuration that did not
 pass test scenario 4.
 Seeing the test results in light of related work, we do not consider the
 current physics and sensor modelling sufficiently realistic to evaluate
 autopilot logic for real navigation scenarios.
\end_layout

\begin_layout Chapter
Conclusion
\begin_inset CommandInset label
LatexCommand label
name "cha:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
We set out to develop a working autopilot for small model helicopters and
 to design a simulator software to verify its correctness.
 The implementation spans several academic disciplines and required us to
 do a thorough research on regulatory systems, sensor specifications, state
 estimation and physics simulation.
 The thesis continued the work from our pre-study on methods of flight simulatio
n, which provided some insight into aerodynamics and visualization techniques.
 Combined with our background in computer science this enabled us to build
 a simulator software to verify the correctness of the autopilot logic.
 
\end_layout

\begin_layout Standard
We proposed three methods for helicopter autopilot logic and the method
 of velocity controlled cyclic navigation proved stable and is considered
 a good candidate for future extensions of this work.
 We also proposed a method for autopilot assisted control that successfully
 enabled any person with little or no flying experience to safely maneuver
 the helicopter by joystick.
 This should prove very useful in the outlined search-and-rescue scenario,
 where swarms of autonomous helicopters aid in the search and send live
 pictures back to a station monitored by human operators.
 If an operator spots something of interest then he or she can assume manual
 control over a helicopter to further investigate certain areas.
\end_layout

\begin_layout Standard
Due to the scope of the project we had to make some simplifications and
 this resulted in state estimates that were 40% more accurate than the results
 of related work.
 The virtual sensors are not modelled to incorporate issues such as environmenta
l influences, undersampling, biased measurements and non-Gaussian noise
 that would increase the uncertainty.
 The GPS/INS Kalman filter only supports linear estimation so were not able
 to model orientation by IMU measurements.
 Instead we inserted random errors in the orientation to compensate for
 the missing uncertainty contribution.
 In addition the realism of the physics model suffered from using a simple
 flight dynamics model with empirically chosen coefficients for drag and
 lift.
 
\end_layout

\begin_layout Standard
The final implementation was a proof-of-concept that, although with major
 simplifications in both physics and sensor modelling, the test results
 clearly indicate that the autopilot is capable of controlled flight and
 the Kalman filter improves the state estimation significantly compared
 to relying on individual sensor measurements.
 We did measure the autopilot performance when modelling the sensors by
 datasheets, but due to the simplifications we do not consider the results
 sufficiently realistic to evaluate whether the autopilot could function
 in a real navigation scenario or not.
 However, the results prove that the autopilot works on a conceptual basis.
 With future improvements to physics and sensor modelling we believe the
 simulator could be used to develop autopilots for real autonomous navigation.
 Also, the autopilot component should prove viable for reuse in physics
 oriented games to enable realistic maneuvering of AI-controlled aircrafts.
\end_layout

\begin_layout Chapter
Future Work
\begin_inset CommandInset label
LatexCommand label
name "cha:Future-Work"

\end_inset


\end_layout

\begin_layout Standard
There were a number of shortcomings in the implementation that we would
 like to see improved in future extensions.
 The virtual sensors need to model noise and measurements in a realistic
 manner by accounting for external influences, undersampling of truth, precision
, inaccuracy, biasing and non-Gaussian noise.
 For example, in real world applications the accelerometers would suffer
 greatly from vibration in the fuselage during flight and introduce a lot
 more uncertainty in the INS estimate.
\end_layout

\begin_layout Standard
The physics model should model angular velocity from the torque generated
 by cyclic controls, rotor velocity, rotor inertia, winds, turbulence and
 other advanced aerodynamic phenomena.
 For example, model helicopters are known to become unstable when flying
 near the ground due to turbulent flow of the main rotor downwash being
 recycled back into the inflow.
 Also, the lift and coefficients should depend on the relative airflow angle
 and velocity.
 A future extension to the physics should also be compared with real flight
 experiments to further refine the realism.
\end_layout

\begin_layout Standard
We would like to see different configurations of helicopter flight dynamics
 to challenge the autopilot with different flight behavior.
 It should be possible to automatically calibrate the autopilot to each
 configuration by performing specific maneuvers and measuring how joystick
 outputs over time causes change in position, orientation and their derivatives.
 When properly calibrated the autopilot should be able to navigate blindly
 for short periods of time, such as when the GPS loses reception or any
 sensors become faulty.
 This could then be used to perform emergency landing procedures.
\end_layout

\begin_layout Standard
The autopilot component should be ported to a microcontroller for testing
 with real sensors.
 Only then can one with confidence measure what levels of uncertainty to
 expect during real flights.
 These results will then be used to further enhance the realism of the modelled
 sensors and the autopilot simulation.
\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
phantomsection
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "andreas"
options "bibtotoc,elsarticle-num"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
User Manual
\begin_inset CommandInset label
LatexCommand label
name "cha:Appendix-UserManual"

\end_inset


\end_layout

\begin_layout Section
Running the Flight Demo
\end_layout

\begin_layout Standard
Included in the digital content is both source code and pre-compiled binary
 files.
 To run the flight demo simply run the shortcut located at 
\emph on
/bin/Run Demo
\emph default
.
 To enable head tracking of the HMD for cockpit camera mode one must run
 the local VRPN server prior to running the simulator, located at 
\emph on
C:
\backslash
vrpn
\backslash
vrpn
\backslash
pc_win32
\backslash
server_src
\backslash
vrpn_server
\backslash
Release
\backslash
vrpn_server.exe
\emph default
 on the test computer.
 All configurations for the demo are found in the files as specified in
 appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Appendix-ConfigurationFiles"

\end_inset

.
\end_layout

\begin_layout Subsection
Keyboard and Mouse Shortcuts
\end_layout

\begin_layout Standard
Listed are keyboard and mouse shortcuts that can be accessed when running
 the simulator.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key / Mouse
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chase camera
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cockpit camera
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fixed camera
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Free camera
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Space
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reset / Next test scenario
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Open live flight logger
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PrntScrn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Screenshot
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Up/Down
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change time of day
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Right-Click
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Open PID configuration
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Reproducing the Test Results
\end_layout

\begin_layout Standard
To run the tests simply execute the batch file located at 
\emph on
/bin/Run Tests.bat
\emph default
.
 This will run all four test configurations in sequence and save the results
 to 
\emph on
/bin/Test Results/
\emph default
.
 Note that the results may differ slightly due to random processes in the
 simulation.
 The output files are structured as follows.
\end_layout

\begin_layout Description

\series medium
test_results.txt Statistics for all the test scenarios run by that specific
 test configuration.
\end_layout

\begin_layout Description

\series medium
TestConfiguration.xml Configuration of sensors, autopilot and test scenarios.
\end_layout

\begin_layout Description

\series medium
flightlog_<scenario>.xml The flight log data.
\end_layout

\begin_layout Standard
To visualize a flight log simply run the review tool located at 
\emph on
/bin/Flight Log Review Tool/Review.exe 
\emph default
and drag and drop the flight log .xml file to the window.
 Comparing flight logs for a specific test scenario is more difficult.
 There must be exactly four .xml files named 
\begin_inset Quotes eld
\end_inset

ex1.xml
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

ex4.xml
\begin_inset Quotes erd
\end_inset

 corresponding to the flight logs for configurations 1-4 on the same test
 scenario.
 Drag these four files simultaneously to the window for comparison.
 See 
\emph on
docs/Masterprosjekt/test results/
\emph default
 for an example on how we organized our files to easily compare them.
\end_layout

\begin_layout Standard
Note that test configurations 1 and 2 requires changes in program code to
 reproduce the results.
 Configuration 1 needs changes in code to use world state instead of estimated
 state.
 Configuration 2 requires the autopilot to navigate by INS estimation only
 and we did not make this a configurable option.
 Configurations 3 and 4, however, are reproducible by using the batch file
 system.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO consider fixing 1 and 2 reproducible and re-verify 3 and 4 are reproducible
 now that code was reverted back to using sensors etc..
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Configuration Files
\begin_inset CommandInset label
LatexCommand label
name "cha:Appendix-ConfigurationFiles"

\end_inset


\end_layout

\begin_layout Standard
To let the user change configurations without having to re-compile the program
 code we created some configuration files.
 We will briefly describe the function and syntax of the configuration files
 here.
\end_layout

\begin_layout Section
TestConfiguration.xml
\begin_inset CommandInset label
LatexCommand label
name "sec:TestConfiguration.xml"

\end_inset


\end_layout

\begin_layout Standard
An example test configuration is listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-TestConfiguration.xml-example."

\end_inset

.
 The first part defines standard deviations for the Gaussian modelled noise
 of accelerometer and GPS measurements.
 OrientationAngleNoiseStdDev defines the distribution of noise for each
 yaw, pitch and roll angles to compensate for not using gyroscopes to estimate
 orientation.
 
\end_layout

\begin_layout Standard
The list of MaxHVelocity elements tells the autopilot what max horizontal
 speed (in m/s) to use when navigating.
 If the helicopter crashes in a test scenario it will retry with velocity
 settings in sequence until it either passes or fails for every setting.
 The list of ScenarioName describes the scenarios that the autopilot will
 run and their definitions are listed in the Scenarios.xml file.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}   
\end_layout

\begin_layout Plain Layout

<root>   
\end_layout

\begin_layout Plain Layout

  <TestConfiguration>     
\end_layout

\begin_layout Plain Layout

    <SensorSpecifications>       
\end_layout

\begin_layout Plain Layout

      <Accelerometer> 
\end_layout

\begin_layout Plain Layout

       <Frequency>60</Frequency>         
\end_layout

\begin_layout Plain Layout

       <NoiseStdDev>
\end_layout

\begin_layout Plain Layout

         <Forward>7.08E-3</Forward>                     
\end_layout

\begin_layout Plain Layout

         <Right>7.08E-3</Right>                     
\end_layout

\begin_layout Plain Layout

         <Up>8.85E-3</Up>         
\end_layout

\begin_layout Plain Layout

       </NoiseStdDev>       
\end_layout

\begin_layout Plain Layout

      </Accelerometer>
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

      <GPSPositionAxisStdDev>3.3</GPSPositionAxisStdDev>             
\end_layout

\begin_layout Plain Layout

      <GPSVelocityAxisStdDev>0.05</GPSVelocityAxisStdDev>
\end_layout

\begin_layout Plain Layout

      <OrientationAngleNoiseStdDev>2</OrientationAngleNoiseStdDev>     
\end_layout

\begin_layout Plain Layout

    </SensorSpecifications>
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    <MaxHVelocity>10</MaxHVelocity>     
\end_layout

\begin_layout Plain Layout

    <MaxHVelocity>5</MaxHVelocity>     
\end_layout

\begin_layout Plain Layout

    <MaxHVelocity>2</MaxHVelocity>     
\end_layout

\begin_layout Plain Layout

    <MaxHVelocity>1</MaxHVelocity>
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    <ScenarioName>A-B Short Flat</ScenarioName>     
\end_layout

\begin_layout Plain Layout

    <ScenarioName>Circle Large Hilly</ScenarioName>     
\end_layout

\begin_layout Plain Layout

    <ScenarioName>Circle Medium Sloped</ScenarioName>     
\end_layout

\begin_layout Plain Layout

    <ScenarioName>Circle Precision Short Flat</ScenarioName>   
\end_layout

\begin_layout Plain Layout

  </TestConfiguration> 
\end_layout

\begin_layout Plain Layout

</root>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TestConfiguration.xml example.
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-TestConfiguration.xml-example."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Scenarios.xml
\begin_inset CommandInset label
LatexCommand label
name "sec:Scenarios.xml"

\end_inset


\end_layout

\begin_layout Standard
This file holds the definitions of all the scenarios that can be run.
 We used these to define manual flight scenarios as shown in the first example
 and autopilot test scenarios as shown in the latter example.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-Scenarios.xml-Fields-and-values"

\end_inset

 lists the possible elements and their values.
 Examples shown in tables 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-Scenarios.xml-example-1"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-Scenarios.xml-example-2"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="2">
<features>
<column alignment="center" valignment="top" width="3.5cm">
<column alignment="center" valignment="top" width="11.5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
XML Element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description / Possible Values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PreSelectedScenario
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name of scenario to load on start-up (not test mode).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SwapStereo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Swap left and right eyes in stereo mode.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RenderMode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rendering technique.
\begin_inset Newline newline
\end_inset


\emph on
Normal, StereoCrossConverged, Stereo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Scenario
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CameraType
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Chase, Fixed, Free, Cockpit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Scene
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List of world objects to load.
 
\begin_inset Newline newline
\end_inset


\emph on
Terrain, Skydome, Forest, Ground, Barrels, CurrentWaypoint.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Helicopter
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EngineSound
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toggle audio.
\emph on

\begin_inset Newline newline
\end_inset

true, false
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PlayerControlled
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toggle autopilot or manual flight.
\emph on

\begin_inset Newline newline
\end_inset

true, false
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
StartPosition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Start position of helicopter in meters.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Task
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Toggle loop of waypoints.
\emph on

\begin_inset Newline newline
\end_inset

true, false
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HoldHeightAbove..
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target altitude above ground in meters.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DefaultWaypointRadius
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max distance to pass a waypoint in meters.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Waypoint
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The waypoint function in navigation.
\begin_inset Newline newline
\end_inset


\emph on
Intermediate, Hover, TestDestination, Land
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Position
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Position of waypoint in meters.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Radius
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overrides the default radius.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fields and values for Scenarios.xml.
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-Scenarios.xml-Fields-and-values"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}   
\end_layout

\begin_layout Plain Layout

<root>   
\end_layout

\begin_layout Plain Layout

  <PreSelectedScenario>Circle Medium Sloped</PreSelectedScenario>
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  <Scenario Name="Terrain Flight Demo">     
\end_layout

\begin_layout Plain Layout

    <CameraType>Chase</CameraType>     
\end_layout

\begin_layout Plain Layout

    <Scene>       
\end_layout

\begin_layout Plain Layout

      <Terrain/>       
\end_layout

\begin_layout Plain Layout

      <Skydome />     
\end_layout

\begin_layout Plain Layout

    </Scene>     
\end_layout

\begin_layout Plain Layout

    <Helicopter>       
\end_layout

\begin_layout Plain Layout

      <EngineSound>false</EngineSound>       
\end_layout

\begin_layout Plain Layout

      <PlayerControlled>true</PlayerControlled>       
\end_layout

\begin_layout Plain Layout

      <StartPosition X="128" Y="70" Z="128" />       
\end_layout

\begin_layout Plain Layout

      <Task>         
\end_layout

\begin_layout Plain Layout

        <Loop>false</Loop>         
\end_layout

\begin_layout Plain Layout

        <Waypoint>           
\end_layout

\begin_layout Plain Layout

          <Type>Land</Type>           
\end_layout

\begin_layout Plain Layout

          <Position X="128" Y="70" Z="128" />         
\end_layout

\begin_layout Plain Layout

        </Waypoint>       
\end_layout

\begin_layout Plain Layout

      </Task>     
\end_layout

\begin_layout Plain Layout

    </Helicopter>   
\end_layout

\begin_layout Plain Layout

  </Scenario>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scenarios.xml example 1 - Manual flight.
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-Scenarios.xml-example-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

<Scenario Name="Circle Medium Sloped">    
\end_layout

\begin_layout Plain Layout

    <TimeoutSeconds>100</TimeoutSeconds>     
\end_layout

\begin_layout Plain Layout

    <Scene>       
\end_layout

\begin_layout Plain Layout

      <Terrain Width="256" MinHeight="0" MaxHeight="30" />       
\end_layout

\begin_layout Plain Layout

      <Skydome />       
\end_layout

\begin_layout Plain Layout

      <CurrentWaypoint />     
\end_layout

\begin_layout Plain Layout

    </Scene>     
\end_layout

\begin_layout Plain Layout

    <Helicopter>       
\end_layout

\begin_layout Plain Layout

      <StartPosition X="150" Y="-1" Z="180" />       
\end_layout

\begin_layout Plain Layout

      <Task>         
\end_layout

\begin_layout Plain Layout

        <HoldHeightAboveGround>5</HoldHeightAboveGround>        
\end_layout

\begin_layout Plain Layout

        <WaypointRadius>5</WaypointRadius>         
\end_layout

\begin_layout Plain Layout

        <Waypoint>           
\end_layout

\begin_layout Plain Layout

          <Type>Intermediate</Type>          
\end_layout

\begin_layout Plain Layout

          <Position X="180" Y="-1" Z="150" />         
\end_layout

\begin_layout Plain Layout

        </Waypoint>         
\end_layout

\begin_layout Plain Layout

        <Waypoint>           
\end_layout

\begin_layout Plain Layout

          <Type>Intermediate</Type>           
\end_layout

\begin_layout Plain Layout

          <Position X="150" Y="-1" Z="120" />         
\end_layout

\begin_layout Plain Layout

        </Waypoint>         
\end_layout

\begin_layout Plain Layout

        <Waypoint>           
\end_layout

\begin_layout Plain Layout

          <Type>Intermediate</Type>           
\end_layout

\begin_layout Plain Layout

          <Position X="120" Y="-1" Z="150" />         
\end_layout

\begin_layout Plain Layout

        </Waypoint>         
\end_layout

\begin_layout Plain Layout

        <Waypoint>           
\end_layout

\begin_layout Plain Layout

          <Type>TestDestination</Type>           
\end_layout

\begin_layout Plain Layout

          <Position X="150" Y="-1" Z="180" />         
\end_layout

\begin_layout Plain Layout

        </Waypoint>       
\end_layout

\begin_layout Plain Layout

      </Task>     
\end_layout

\begin_layout Plain Layout

    </Helicopter>   
\end_layout

\begin_layout Plain Layout

  </Scenario>
\end_layout

\begin_layout Plain Layout

</root>   
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Scenarios.xml example 2 - Autonomous flight.
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-Scenarios.xml-example-2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
PIDSetups.xml
\begin_inset CommandInset label
LatexCommand label
name "sec:PIDSetups.xml"

\end_inset


\end_layout

\begin_layout Standard
We tuned our PID settings by the methods described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:PID-Tuning"

\end_inset

 and the final configuration is shown in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-PIDSetups.xml-example"

\end_inset

.
 Note that the PID coefficients are inverted in the configuration because
 this was easier to relate to.
 Actual coefficients used in calculations are found by 
\begin_inset Formula $K_{P}=\frac{1}{P}$
\end_inset

 and similar.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

<root>   
\end_layout

\begin_layout Plain Layout

  <PIDSetup Name="Stable_v1">     
\end_layout

\begin_layout Plain Layout

    <PID Name="PitchAngle" P="30" I="0" D="0" />     
\end_layout

\begin_layout Plain Layout

    <PID Name="RollAngle" P="30" I="0" D="0" />     
\end_layout

\begin_layout Plain Layout

    <PID Name="YawAngle" P="30" I="0" D="0" />     
\end_layout

\begin_layout Plain Layout

    <PID Name="Throttle" P="-0.5" I="-0.5" D="-1" />     
\end_layout

\begin_layout Plain Layout

    <PID Name="Velocity" P="0" I="0" D="-1" />   
\end_layout

\begin_layout Plain Layout

  </PIDSetup> 
\end_layout

\begin_layout Plain Layout

</root>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PIDSetups.xml example.
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-PIDSetups.xml-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
JoystickSetups.xml
\begin_inset CommandInset label
LatexCommand label
name "sec:JoystickSetups.xml"

\end_inset


\end_layout

\begin_layout Standard
In our final implementation we configured two joysticks; Microsoft SideWinder
 Precision 2 and Logitech G940 Flight System.
 Both are shown in tables 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-JoystickSetups.xml-Microsoft"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:AppendixB-JoystickSetups.xml-Logitech"

\end_inset

.
 Note how the Logitech uses data from three separate joystick devices.
 Each JoystickSetup has one or more JoystickDevices.
 Each device has a 8 axes that can be mapped to a function in the simulator
 such as 
\emph on
Roll, Pitch, Yaw, Throttle 
\emph default
and optionally invert the axis.
 To find what logical axis on the joystick corresponds to a physical axis
 use the joystick application located in the 
\emph on
/bin/Joystick Configuration Tool/
\emph default
 folder.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

<root>
\end_layout

\begin_layout Plain Layout

  <JoystickSetup Name="Microsoft SideWinder Precision 2">     
\end_layout

\begin_layout Plain Layout

    <JoystickDevice Name="SideWinder Precision 2 Joystick">
\end_layout

\begin_layout Plain Layout

      <Axis Name="X" Inverted="false">Roll</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Y" Inverted="false">Pitch</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Z" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rx" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Ry" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rz" Inverted="false">Yaw</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="U" Inverted="true">Throttle</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="V" Inverted="false"></Axis>     
\end_layout

\begin_layout Plain Layout

    </JoystickDevice>   
\end_layout

\begin_layout Plain Layout

  </JoystickSetup>
\end_layout

\begin_layout Plain Layout

</root>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
JoystickSetups.xml example - Microsoft SideWinder
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-JoystickSetups.xml-Microsoft"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

<root>
\end_layout

\begin_layout Plain Layout

  <JoystickSetup Name="Logitech G940 Flight System">     
\end_layout

\begin_layout Plain Layout

    <JoystickDevice Name="Logitech G940 Joystick">       
\end_layout

\begin_layout Plain Layout

      <Axis Name="X" Inverted="false">Roll</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Y" Inverted="false">Pitch</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Z" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rx" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Ry" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rz" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="U" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="V" Inverted="false"></Axis>     
\end_layout

\begin_layout Plain Layout

    </JoystickDevice>     
\end_layout

\begin_layout Plain Layout

    <JoystickDevice Name="Logitech G940 Throttle">       
\end_layout

\begin_layout Plain Layout

      <Axis Name="X" Inverted="true">Throttle</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Y" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Z" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rx" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Ry" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rz" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="U" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="V" Inverted="false"></Axis>     
\end_layout

\begin_layout Plain Layout

    </JoystickDevice>     
\end_layout

\begin_layout Plain Layout

    <JoystickDevice Name="Logitech G940 Pedals">       
\end_layout

\begin_layout Plain Layout

      <Axis Name="X" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Y" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Z" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rx" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Ry" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="Rz" Inverted="false">Yaw</Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="U" Inverted="false"></Axis>       
\end_layout

\begin_layout Plain Layout

      <Axis Name="V" Inverted="false"></Axis>     
\end_layout

\begin_layout Plain Layout

    </JoystickDevice>   
\end_layout

\begin_layout Plain Layout

  </JoystickSetup>
\end_layout

\begin_layout Plain Layout

</root>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
JoystickSetups.xml example - Logitech G940
\begin_inset CommandInset label
LatexCommand label
name "tab:AppendixB-JoystickSetups.xml-Logitech"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Sensor Datasheets
\begin_inset CommandInset label
LatexCommand label
name "cha:Appendix-SensorDatasheets"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename References/Sensor Datasheets/GPS FV-M8_Spec.pdf
	lyxscale 25
	extra LaTeX "pages=1-2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename References/Sensor Datasheets/ADXL330.pdf
	lyxscale 25
	extra LaTeX "pages={1,3,4}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename References/Sensor Datasheets/LV-MaxSonar-EZ0-Datasheet.pdf
	lyxscale 25
	extra LaTeX "pages=1-2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename References/Sensor Datasheets/LYPR540AH.pdf
	lyxscale 25
	extra LaTeX "pages={1,5}"

\end_inset


\end_layout

\begin_layout Chapter
Precision Issues
\begin_inset CommandInset label
LatexCommand label
name "cha:Appendix-PrecisionIssues"

\end_inset


\end_layout

\begin_layout Section
Non-deterministic Behavior of Floating-Point Calculations
\begin_inset CommandInset label
LatexCommand label
name "sec:Precision-Float-Operations"

\end_inset


\end_layout

\begin_layout Standard
As mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Estimation-validity"

\end_inset

 the values of result1 and result2 in the following code are not always
 equal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}   
\end_layout

\begin_layout Plain Layout

const float A, B, C, dt; // Any non-zero values
\end_layout

\begin_layout Plain Layout

float result1 = (A*B)*dt;
\end_layout

\begin_layout Plain Layout

float result2 = (A*B); 
\end_layout

\begin_layout Plain Layout

result2 *= dt; 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the results after running the below unit test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}  
\end_layout

\begin_layout Plain Layout

X   
\end_layout

\begin_layout Plain Layout

  Expected: 0.275153548f   
\end_layout

\begin_layout Plain Layout

  But was:  0.275153786f
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The estimated orientation error is very small and only presented itself
 after many iterations in the actual implementation.
 In simulations, as a consequence, the positional estimation reached about
 3cm estimation error after 30 seconds of flight and diverged quickly due
 to errors in velocity estimates.
\end_layout

\begin_layout Standard
The reason we got this behavior was because the compiler may or may not
 decide to use the x86 high-precision flag when performing floating point
 calculations.
 In our pseudo-code, result2 may lose precision compared to result1 because
 it stores a temporary calculation to an intermediary single precision floating
 point variable, which truncates any extra precision.
\end_layout

\begin_layout Standard
Unit test code listing:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}   
\end_layout

\begin_layout Plain Layout

[TestFixture]     
\end_layout

\begin_layout Plain Layout

internal class QuaternionPrecisionTest     
\end_layout

\begin_layout Plain Layout

{         
\end_layout

\begin_layout Plain Layout

[Test]         
\end_layout

\begin_layout Plain Layout

public void Test()         
\end_layout

\begin_layout Plain Layout

{             
\end_layout

\begin_layout Plain Layout

    JoystickOutput output;             
\end_layout

\begin_layout Plain Layout

    output.Pitch = 0.312312432f;             
\end_layout

\begin_layout Plain Layout

    output.Roll = 0.512312432f;             
\end_layout

\begin_layout Plain Layout

    output.Yaw = 0.912312432f;             
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    const float dt = 0.017001f;
\end_layout

\begin_layout Plain Layout

    float pitchRate = output.Pitch * PhysicsConstants.MaxPitchRate;      
       
\end_layout

\begin_layout Plain Layout

    float rollRate = output.Roll * PhysicsConstants.MaxRollRate;         
    
\end_layout

\begin_layout Plain Layout

    float yawRate = output.Yaw * PhysicsConstants.MaxYawRate;
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

    Quaternion orient1 = Quaternion.Identity;             
\end_layout

\begin_layout Plain Layout

    Quaternion orient2 = Quaternion.Identity;
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 10000; i++)             
\end_layout

\begin_layout Plain Layout

    {                 
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      float deltaPitch = (output.Pitch * PhysicsConstants.MaxPitchRate) *
 dt;                 
\end_layout

\begin_layout Plain Layout

      float deltaRoll =  (output.Roll * PhysicsConstants.MaxRollRate) * dt;
\end_layout

\begin_layout Plain Layout

      float deltaYaw =   (output.Yaw * PhysicsConstants.MaxYawRate) * dt;
\end_layout

\begin_layout Plain Layout

                
\end_layout

\begin_layout Plain Layout

      // Add deltas of pitch, roll and yaw to the rotation matrix      
           
\end_layout

\begin_layout Plain Layout

      orient1 = VectorHelper.AddPitchRollYaw(                           
      
\end_layout

\begin_layout Plain Layout

                                orient1, deltaPitch, deltaRoll, deltaYaw);
\end_layout

\begin_layout Plain Layout

              
\end_layout

\begin_layout Plain Layout

      deltaPitch = pitchRate * dt;                 
\end_layout

\begin_layout Plain Layout

      deltaRoll = rollRate * dt;                 
\end_layout

\begin_layout Plain Layout

      deltaYaw = yawRate * dt;                 
\end_layout

\begin_layout Plain Layout

      orient2 = VectorHelper.AddPitchRollYaw(
\end_layout

\begin_layout Plain Layout

                                orient2, deltaPitch, deltaRoll, deltaYaw);
             
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(orient1.X, orient2.X, "X");             
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(orient1.Y, orient2.Y, "Y");             
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(orient1.Z, orient2.Z, "Z");             
\end_layout

\begin_layout Plain Layout

    Assert.AreEqual(orient1.W, orient2.W, "W");         
\end_layout

\begin_layout Plain Layout

  }     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim} 
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Loss of Precision when Transforming Between Body Frame and Navigation Frame
\begin_inset CommandInset label
LatexCommand label
name "sec:Precision-Frames"

\end_inset


\end_layout

\begin_layout Standard
We discovered a precision loss when transforming a vector between reference
 frames and this was particularly noticeable when the simulated acceleration
 vector in navigation frame had to be transformed to the body frame acceleromete
r and then transformed back to navigation frame in the INS.
 We designed a test class FrameConversionPrecisionTest to measure the loss
 for different orientations of the helicopter and here are the results.
\end_layout

\begin_layout Standard
Although the error is typically in the order of 1E-6 for each roundtrip
 transformation this resulted in significant state estimation errors that
 accumulated over time.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{mylisting} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}   
\end_layout

\begin_layout Plain Layout

Body frame pitch(0) roll(0) yaw(0) gave differences of {X:0 Y:0 Z:0}.
\end_layout

\begin_layout Plain Layout

Body frame pitch(0) roll(0) yaw(1) gave differences of {X:9,536743E-07 Y:0
 Z:0}.
 
\end_layout

\begin_layout Plain Layout

Body frame pitch(1) roll(0) yaw(0) gave differences of {X:0 Y:9,536743E-07
 Z:1,907349E-06}.
 
\end_layout

\begin_layout Plain Layout

Body frame pitch(1) roll(1) yaw(0) gave differences of {X:1,907349E-06 Y:0
 Z:3,814697E-06}.
 
\end_layout

\begin_layout Plain Layout

Body frame pitch(0,6) roll(1,7) yaw(2,1) gave differences of {X:-2,861023E-06
 Y:-1,430511E-06 Z:0}.
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}   
\end_layout

\begin_layout Plain Layout


\backslash
end{mylisting} 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
